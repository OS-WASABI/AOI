/* soapC.cpp
   Generated by gSOAP 2.8.78 for cap.h

gSOAP XML Web services tools
Copyright (C) 2000-2018, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

SOAP_SOURCE_STAMP("@(#) soapC.cpp ver 2.8.78 2019-02-06 03:49:22 GMT")


SOAP_FMAC3 void * SOAP_FMAC4 soap_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{	(void)type;
	switch (t)
	{
	case SOAP_TYPE_std__string:
		return (void*)soap_instantiate_std__string(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__requestParameterList:
		return (void*)soap_instantiate_ns2__requestParameterList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__parameterListItem:
		return (void*)soap_instantiate_ns2__parameterListItem(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__responseParameterList:
		return (void*)soap_instantiate_ns3__responseParameterList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__subParameterListItem:
		return (void*)soap_instantiate_ns3__subParameterListItem(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__parameterListItem:
		return (void*)soap_instantiate__ns3__parameterListItem(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns22__alert_info_eventCode:
		return (void*)soap_instantiate__ns22__alert_info_eventCode(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns22__alert_info_parameter:
		return (void*)soap_instantiate__ns22__alert_info_parameter(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns22__alert_info_resource:
		return (void*)soap_instantiate__ns22__alert_info_resource(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns22__alert_info_area_geocode:
		return (void*)soap_instantiate__ns22__alert_info_area_geocode(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns22__alert_info_area:
		return (void*)soap_instantiate__ns22__alert_info_area(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns22__alert_info:
		return (void*)soap_instantiate__ns22__alert_info(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns22__alert:
		return (void*)soap_instantiate__ns22__alert(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__postCAPRequestTypeDef:
		return (void*)soap_instantiate__ns1__postCAPRequestTypeDef(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__CAPServiceException:
		return (void*)soap_instantiate__ns1__CAPServiceException(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__postCAPResponseTypeDef:
		return (void*)soap_instantiate__ns1__postCAPResponseTypeDef(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__messageResponseTypeDef:
		return (void*)soap_instantiate__ns1__messageResponseTypeDef(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__CAPHeaderTypeDef:
		return (void*)soap_instantiate__ns1__CAPHeaderTypeDef(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		return (void*)soap_instantiate_SOAP_ENV__Header(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		return (void*)soap_instantiate_SOAP_ENV__Detail(soap, -1, type, arrayType, n);
#endif
	case SOAP_TYPE___ns1__getRequest:
		return (void*)soap_instantiate___ns1__getRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__postCAP:
		return (void*)soap_instantiate___ns1__postCAP(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getMessage:
		return (void*)soap_instantiate___ns1__getMessage(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__anyURI:
		return (void*)soap_instantiate_xsd__anyURI(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__decimal:
		return (void*)soap_instantiate_xsd__decimal(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__integer:
		return (void*)soap_instantiate_xsd__integer(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__language:
		return (void*)soap_instantiate_xsd__language(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTo_ns22__alert:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTo_ns22__alert(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOf_XML:
		return (void*)soap_instantiate_std__vectorTemplateOf_XML(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOf_ns22__alert_info:
		return (void*)soap_instantiate_std__vectorTemplateOf_ns22__alert_info(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOf_ns22__alert_info_area:
		return (void*)soap_instantiate_std__vectorTemplateOf_ns22__alert_info_area(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOf_ns22__alert_info_area_geocode:
		return (void*)soap_instantiate_std__vectorTemplateOf_ns22__alert_info_area_geocode(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOf_ns22__alert_info_resource:
		return (void*)soap_instantiate_std__vectorTemplateOf_ns22__alert_info_resource(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOf_ns22__alert_info_parameter:
		return (void*)soap_instantiate_std__vectorTemplateOf_ns22__alert_info_parameter(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOf_ns22__alert_info_eventCode:
		return (void*)soap_instantiate_std__vectorTemplateOf_ns22__alert_info_eventCode(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOf_ns22__alert_info_responseType:
		return (void*)soap_instantiate_std__vectorTemplateOf_ns22__alert_info_responseType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOf_ns22__alert_info_category:
		return (void*)soap_instantiate_std__vectorTemplateOf_ns22__alert_info_category(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons3__subParameterListItem:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons3__subParameterListItem(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTo_ns3__parameterListItem:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTo_ns3__parameterListItem(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfstd__string:
		return (void*)soap_instantiate_std__vectorTemplateOfstd__string(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__parameterListItem:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons2__parameterListItem(soap, -1, type, arrayType, n);
	}
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_fdelete(struct soap *soap, struct soap_clist *p)
{
	(void)soap; /* appease -Wall -Werror */
	if (!p->ptr)
		return SOAP_OK;
	switch (p->type)
	{
	case SOAP_TYPE_std__string:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_ns2__requestParameterList:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns2__requestParameterList*>(p->ptr), ns2__requestParameterList);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns2__requestParameterList*>(p->ptr), ns2__requestParameterList);
		break;
	case SOAP_TYPE_ns2__parameterListItem:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns2__parameterListItem*>(p->ptr), ns2__parameterListItem);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns2__parameterListItem*>(p->ptr), ns2__parameterListItem);
		break;
	case SOAP_TYPE_ns3__responseParameterList:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns3__responseParameterList*>(p->ptr), ns3__responseParameterList);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns3__responseParameterList*>(p->ptr), ns3__responseParameterList);
		break;
	case SOAP_TYPE_ns3__subParameterListItem:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns3__subParameterListItem*>(p->ptr), ns3__subParameterListItem);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns3__subParameterListItem*>(p->ptr), ns3__subParameterListItem);
		break;
	case SOAP_TYPE__ns3__parameterListItem:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns3__parameterListItem*>(p->ptr), _ns3__parameterListItem);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns3__parameterListItem*>(p->ptr), _ns3__parameterListItem);
		break;
	case SOAP_TYPE__ns22__alert_info_eventCode:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns22__alert_info_eventCode*>(p->ptr), _ns22__alert_info_eventCode);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns22__alert_info_eventCode*>(p->ptr), _ns22__alert_info_eventCode);
		break;
	case SOAP_TYPE__ns22__alert_info_parameter:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns22__alert_info_parameter*>(p->ptr), _ns22__alert_info_parameter);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns22__alert_info_parameter*>(p->ptr), _ns22__alert_info_parameter);
		break;
	case SOAP_TYPE__ns22__alert_info_resource:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns22__alert_info_resource*>(p->ptr), _ns22__alert_info_resource);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns22__alert_info_resource*>(p->ptr), _ns22__alert_info_resource);
		break;
	case SOAP_TYPE__ns22__alert_info_area_geocode:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns22__alert_info_area_geocode*>(p->ptr), _ns22__alert_info_area_geocode);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns22__alert_info_area_geocode*>(p->ptr), _ns22__alert_info_area_geocode);
		break;
	case SOAP_TYPE__ns22__alert_info_area:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns22__alert_info_area*>(p->ptr), _ns22__alert_info_area);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns22__alert_info_area*>(p->ptr), _ns22__alert_info_area);
		break;
	case SOAP_TYPE__ns22__alert_info:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns22__alert_info*>(p->ptr), _ns22__alert_info);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns22__alert_info*>(p->ptr), _ns22__alert_info);
		break;
	case SOAP_TYPE__ns22__alert:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns22__alert*>(p->ptr), _ns22__alert);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns22__alert*>(p->ptr), _ns22__alert);
		break;
	case SOAP_TYPE__ns1__postCAPRequestTypeDef:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__postCAPRequestTypeDef*>(p->ptr), _ns1__postCAPRequestTypeDef);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__postCAPRequestTypeDef*>(p->ptr), _ns1__postCAPRequestTypeDef);
		break;
	case SOAP_TYPE__ns1__CAPServiceException:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__CAPServiceException*>(p->ptr), _ns1__CAPServiceException);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__CAPServiceException*>(p->ptr), _ns1__CAPServiceException);
		break;
	case SOAP_TYPE__ns1__postCAPResponseTypeDef:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__postCAPResponseTypeDef*>(p->ptr), _ns1__postCAPResponseTypeDef);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__postCAPResponseTypeDef*>(p->ptr), _ns1__postCAPResponseTypeDef);
		break;
	case SOAP_TYPE__ns1__messageResponseTypeDef:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__messageResponseTypeDef*>(p->ptr), _ns1__messageResponseTypeDef);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__messageResponseTypeDef*>(p->ptr), _ns1__messageResponseTypeDef);
		break;
	case SOAP_TYPE__ns1__CAPHeaderTypeDef:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__CAPHeaderTypeDef*>(p->ptr), _ns1__CAPHeaderTypeDef);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__CAPHeaderTypeDef*>(p->ptr), _ns1__CAPHeaderTypeDef);
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct SOAP_ENV__Header*>(p->ptr), struct SOAP_ENV__Header);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct SOAP_ENV__Header*>(p->ptr), struct SOAP_ENV__Header);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct SOAP_ENV__Detail*>(p->ptr), struct SOAP_ENV__Detail);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct SOAP_ENV__Detail*>(p->ptr), struct SOAP_ENV__Detail);
		break;
#endif
	case SOAP_TYPE___ns1__getRequest:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__getRequest*>(p->ptr), struct __ns1__getRequest);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__getRequest*>(p->ptr), struct __ns1__getRequest);
		break;
	case SOAP_TYPE___ns1__postCAP:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__postCAP*>(p->ptr), struct __ns1__postCAP);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__postCAP*>(p->ptr), struct __ns1__postCAP);
		break;
	case SOAP_TYPE___ns1__getMessage:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__getMessage*>(p->ptr), struct __ns1__getMessage);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__getMessage*>(p->ptr), struct __ns1__getMessage);
		break;
	case SOAP_TYPE_xsd__anyURI:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_xsd__decimal:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_xsd__integer:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_xsd__language:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTo_ns22__alert:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<_ns22__alert *> *>(p->ptr), std::vector<_ns22__alert *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<_ns22__alert *> *>(p->ptr), std::vector<_ns22__alert *> );
		break;
	case SOAP_TYPE_std__vectorTemplateOf_XML:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<char *> *>(p->ptr), std::vector<char *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<char *> *>(p->ptr), std::vector<char *> );
		break;
	case SOAP_TYPE_std__vectorTemplateOf_ns22__alert_info:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<_ns22__alert_info> *>(p->ptr), std::vector<_ns22__alert_info> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<_ns22__alert_info> *>(p->ptr), std::vector<_ns22__alert_info> );
		break;
	case SOAP_TYPE_std__vectorTemplateOf_ns22__alert_info_area:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<_ns22__alert_info_area> *>(p->ptr), std::vector<_ns22__alert_info_area> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<_ns22__alert_info_area> *>(p->ptr), std::vector<_ns22__alert_info_area> );
		break;
	case SOAP_TYPE_std__vectorTemplateOf_ns22__alert_info_area_geocode:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<_ns22__alert_info_area_geocode> *>(p->ptr), std::vector<_ns22__alert_info_area_geocode> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<_ns22__alert_info_area_geocode> *>(p->ptr), std::vector<_ns22__alert_info_area_geocode> );
		break;
	case SOAP_TYPE_std__vectorTemplateOf_ns22__alert_info_resource:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<_ns22__alert_info_resource> *>(p->ptr), std::vector<_ns22__alert_info_resource> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<_ns22__alert_info_resource> *>(p->ptr), std::vector<_ns22__alert_info_resource> );
		break;
	case SOAP_TYPE_std__vectorTemplateOf_ns22__alert_info_parameter:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<_ns22__alert_info_parameter> *>(p->ptr), std::vector<_ns22__alert_info_parameter> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<_ns22__alert_info_parameter> *>(p->ptr), std::vector<_ns22__alert_info_parameter> );
		break;
	case SOAP_TYPE_std__vectorTemplateOf_ns22__alert_info_eventCode:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<_ns22__alert_info_eventCode> *>(p->ptr), std::vector<_ns22__alert_info_eventCode> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<_ns22__alert_info_eventCode> *>(p->ptr), std::vector<_ns22__alert_info_eventCode> );
		break;
	case SOAP_TYPE_std__vectorTemplateOf_ns22__alert_info_responseType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<enum _ns22__alert_info_responseType> *>(p->ptr), std::vector<enum _ns22__alert_info_responseType> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<enum _ns22__alert_info_responseType> *>(p->ptr), std::vector<enum _ns22__alert_info_responseType> );
		break;
	case SOAP_TYPE_std__vectorTemplateOf_ns22__alert_info_category:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<enum _ns22__alert_info_category> *>(p->ptr), std::vector<enum _ns22__alert_info_category> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<enum _ns22__alert_info_category> *>(p->ptr), std::vector<enum _ns22__alert_info_category> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons3__subParameterListItem:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<ns3__subParameterListItem *> *>(p->ptr), std::vector<ns3__subParameterListItem *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<ns3__subParameterListItem *> *>(p->ptr), std::vector<ns3__subParameterListItem *> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTo_ns3__parameterListItem:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<_ns3__parameterListItem *> *>(p->ptr), std::vector<_ns3__parameterListItem *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<_ns3__parameterListItem *> *>(p->ptr), std::vector<_ns3__parameterListItem *> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfstd__string:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<std::string> *>(p->ptr), std::vector<std::string> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<std::string> *>(p->ptr), std::vector<std::string> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__parameterListItem:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<ns2__parameterListItem *> *>(p->ptr), std::vector<ns2__parameterListItem *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<ns2__parameterListItem *> *>(p->ptr), std::vector<ns2__parameterListItem *> );
		break;
	default:
		return SOAP_ERR;
	}
	return SOAP_OK;
}

#ifdef WIN32
#pragma warning(push)
// do not warn on switch w/o cases
#pragma warning(disable:4065)
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_fbase(int t, int b)
{
	(void)t; (void)b; /* appease -Wall -Werror */
	return 0;
}
#ifdef WIN32
#pragma warning(pop)
#endif

#ifndef WITH_NOIDREF
#ifdef WIN32
#pragma warning(push)
// do not warn on switch w/o cases
#pragma warning(disable:4065)
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_finsert(struct soap *soap, int t, int tt, void *p, size_t index, const void *q, void **x)
{
	(void)soap; (void)t; (void)p; (void)index; (void)q; (void)x; /* appease -Wall -Werror */
	switch (tt)
	{
	case SOAP_TYPE_std__vectorTemplateOfPointerTo_ns22__alert:
		if (t == SOAP_TYPE__ns22__alert || soap_fbase(t, SOAP_TYPE__ns22__alert))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<_ns22__alert *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<_ns22__alert *> *)p)[index] = *(_ns22__alert **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOf_XML:
		if (t == SOAP_TYPE__XML)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<char *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<char *> *)p)[index] = *(char **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOf_ns22__alert_info:
		if (t == SOAP_TYPE__ns22__alert_info)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<_ns22__alert_info>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<_ns22__alert_info> *)p)[index] = *(_ns22__alert_info *)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOf_ns22__alert_info_area:
		if (t == SOAP_TYPE__ns22__alert_info_area)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<_ns22__alert_info_area>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<_ns22__alert_info_area> *)p)[index] = *(_ns22__alert_info_area *)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOf_ns22__alert_info_area_geocode:
		if (t == SOAP_TYPE__ns22__alert_info_area_geocode)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<_ns22__alert_info_area_geocode>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<_ns22__alert_info_area_geocode> *)p)[index] = *(_ns22__alert_info_area_geocode *)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOf_ns22__alert_info_resource:
		if (t == SOAP_TYPE__ns22__alert_info_resource)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<_ns22__alert_info_resource>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<_ns22__alert_info_resource> *)p)[index] = *(_ns22__alert_info_resource *)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOf_ns22__alert_info_parameter:
		if (t == SOAP_TYPE__ns22__alert_info_parameter)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<_ns22__alert_info_parameter>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<_ns22__alert_info_parameter> *)p)[index] = *(_ns22__alert_info_parameter *)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOf_ns22__alert_info_eventCode:
		if (t == SOAP_TYPE__ns22__alert_info_eventCode)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<_ns22__alert_info_eventCode>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<_ns22__alert_info_eventCode> *)p)[index] = *(_ns22__alert_info_eventCode *)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOf_ns22__alert_info_responseType:
		if (t == SOAP_TYPE__ns22__alert_info_responseType)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<enum _ns22__alert_info_responseType>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<enum _ns22__alert_info_responseType> *)p)[index] = *(enum _ns22__alert_info_responseType *)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOf_ns22__alert_info_category:
		if (t == SOAP_TYPE__ns22__alert_info_category)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<enum _ns22__alert_info_category>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<enum _ns22__alert_info_category> *)p)[index] = *(enum _ns22__alert_info_category *)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons3__subParameterListItem:
		if (t == SOAP_TYPE_ns3__subParameterListItem || soap_fbase(t, SOAP_TYPE_ns3__subParameterListItem))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns3__subParameterListItem *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns3__subParameterListItem *> *)p)[index] = *(ns3__subParameterListItem **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTo_ns3__parameterListItem:
		if (t == SOAP_TYPE__ns3__parameterListItem || soap_fbase(t, SOAP_TYPE__ns3__parameterListItem))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<_ns3__parameterListItem *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<_ns3__parameterListItem *> *)p)[index] = *(_ns3__parameterListItem **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfstd__string:
		if (t == SOAP_TYPE_std__string)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<std::string>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<std::string> *)p)[index] = *(std::string *)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__parameterListItem:
		if (t == SOAP_TYPE_ns2__parameterListItem || soap_fbase(t, SOAP_TYPE_ns2__parameterListItem))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns2__parameterListItem *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns2__parameterListItem *> *)p)[index] = *(ns2__parameterListItem **)q;
		}
		break;
	case SOAP_TYPE_std__string:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_ns2__requestParameterList:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__requestParameterList type=%d location=%p object=%p\n", t, p, q));
		*(ns2__requestParameterList*)p = *(ns2__requestParameterList*)q;
		break;
	case SOAP_TYPE_ns2__parameterListItem:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__parameterListItem type=%d location=%p object=%p\n", t, p, q));
		*(ns2__parameterListItem*)p = *(ns2__parameterListItem*)q;
		break;
	case SOAP_TYPE_ns3__responseParameterList:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns3__responseParameterList type=%d location=%p object=%p\n", t, p, q));
		*(ns3__responseParameterList*)p = *(ns3__responseParameterList*)q;
		break;
	case SOAP_TYPE_ns3__subParameterListItem:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns3__subParameterListItem type=%d location=%p object=%p\n", t, p, q));
		*(ns3__subParameterListItem*)p = *(ns3__subParameterListItem*)q;
		break;
	case SOAP_TYPE__ns3__parameterListItem:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns3__parameterListItem type=%d location=%p object=%p\n", t, p, q));
		*(_ns3__parameterListItem*)p = *(_ns3__parameterListItem*)q;
		break;
	case SOAP_TYPE__ns22__alert_info_eventCode:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns22__alert_info_eventCode type=%d location=%p object=%p\n", t, p, q));
		*(_ns22__alert_info_eventCode*)p = *(_ns22__alert_info_eventCode*)q;
		break;
	case SOAP_TYPE__ns22__alert_info_parameter:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns22__alert_info_parameter type=%d location=%p object=%p\n", t, p, q));
		*(_ns22__alert_info_parameter*)p = *(_ns22__alert_info_parameter*)q;
		break;
	case SOAP_TYPE__ns22__alert_info_resource:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns22__alert_info_resource type=%d location=%p object=%p\n", t, p, q));
		*(_ns22__alert_info_resource*)p = *(_ns22__alert_info_resource*)q;
		break;
	case SOAP_TYPE__ns22__alert_info_area_geocode:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns22__alert_info_area_geocode type=%d location=%p object=%p\n", t, p, q));
		*(_ns22__alert_info_area_geocode*)p = *(_ns22__alert_info_area_geocode*)q;
		break;
	case SOAP_TYPE__ns22__alert_info_area:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns22__alert_info_area type=%d location=%p object=%p\n", t, p, q));
		*(_ns22__alert_info_area*)p = *(_ns22__alert_info_area*)q;
		break;
	case SOAP_TYPE__ns22__alert_info:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns22__alert_info type=%d location=%p object=%p\n", t, p, q));
		*(_ns22__alert_info*)p = *(_ns22__alert_info*)q;
		break;
	case SOAP_TYPE__ns22__alert:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns22__alert type=%d location=%p object=%p\n", t, p, q));
		*(_ns22__alert*)p = *(_ns22__alert*)q;
		break;
	case SOAP_TYPE__ns1__postCAPRequestTypeDef:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__postCAPRequestTypeDef type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__postCAPRequestTypeDef*)p = *(_ns1__postCAPRequestTypeDef*)q;
		break;
	case SOAP_TYPE__ns1__CAPServiceException:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__CAPServiceException type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__CAPServiceException*)p = *(_ns1__CAPServiceException*)q;
		break;
	case SOAP_TYPE__ns1__postCAPResponseTypeDef:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__postCAPResponseTypeDef type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__postCAPResponseTypeDef*)p = *(_ns1__postCAPResponseTypeDef*)q;
		break;
	case SOAP_TYPE__ns1__messageResponseTypeDef:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__messageResponseTypeDef type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__messageResponseTypeDef*)p = *(_ns1__messageResponseTypeDef*)q;
		break;
	case SOAP_TYPE__ns1__CAPHeaderTypeDef:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__CAPHeaderTypeDef type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__CAPHeaderTypeDef*)p = *(_ns1__CAPHeaderTypeDef*)q;
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Header type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Detail type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;
		break;
#endif
	case SOAP_TYPE___ns1__getRequest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__getRequest type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__getRequest*)p = *(struct __ns1__getRequest*)q;
		break;
	case SOAP_TYPE___ns1__postCAP:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__postCAP type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__postCAP*)p = *(struct __ns1__postCAP*)q;
		break;
	case SOAP_TYPE___ns1__getMessage:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__getMessage type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__getMessage*)p = *(struct __ns1__getMessage*)q;
		break;
	case SOAP_TYPE_xsd__anyURI:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_xsd__decimal:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_xsd__integer:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_xsd__language:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	default:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Could not insert type=%d in %d\n", t, tt));
	}
}
#ifdef WIN32
#pragma warning(pop)
#endif
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{
	a = soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
	return a;
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_new_byte(struct soap *soap, int n)
{
	char *a = static_cast<char *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(char)));
	for (char *p = a; p && n--; ++p)
		soap_default_byte(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	if (soap_out_byte(soap, tag ? tag : "byte", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dateTime(struct soap *soap, const char *tag, int id, const time_t *a, const char *type)
{
	return soap_outdateTime(soap, tag, id, a, type, SOAP_TYPE_dateTime);
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_in_dateTime(struct soap *soap, const char *tag, time_t *a, const char *type)
{
	a = soap_indateTime(soap, tag, a, type, SOAP_TYPE_dateTime);
	return a;
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_new_dateTime(struct soap *soap, int n)
{
	time_t *a = static_cast<time_t *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(time_t)));
	for (time_t *p = a; p && n--; ++p)
		soap_default_dateTime(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dateTime(struct soap *soap, const time_t *a, const char *tag, const char *type)
{
	if (soap_out_dateTime(soap, tag ? tag : "dateTime", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_get_dateTime(struct soap *soap, time_t *p, const char *tag, const char *type)
{
	if ((p = soap_in_dateTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes__ns22__alert_info_certainty[] =
{	{ (LONG64)_ns22__alert_info_certainty__Observed, "Observed" },
	{ (LONG64)_ns22__alert_info_certainty__Likely, "Likely" },
	{ (LONG64)_ns22__alert_info_certainty__Possible, "Possible" },
	{ (LONG64)_ns22__alert_info_certainty__Unlikely, "Unlikely" },
	{ (LONG64)_ns22__alert_info_certainty__Unknown, "Unknown" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap__ns22__alert_info_certainty2s(struct soap *soap, enum _ns22__alert_info_certainty n)
{
	const char *s = soap_code_str(soap_codes__ns22__alert_info_certainty, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns22__alert_info_certainty(struct soap *soap, const char *tag, int id, const enum _ns22__alert_info_certainty *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns22__alert_info_certainty), type) || soap_send(soap, soap__ns22__alert_info_certainty2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2_ns22__alert_info_certainty(struct soap *soap, const char *s, enum _ns22__alert_info_certainty *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes__ns22__alert_info_certainty, s);
	if (map)
		*a = (enum _ns22__alert_info_certainty)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 4)
			return soap->error = SOAP_TYPE;
		*a = (enum _ns22__alert_info_certainty)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum _ns22__alert_info_certainty * SOAP_FMAC4 soap_in__ns22__alert_info_certainty(struct soap *soap, const char *tag, enum _ns22__alert_info_certainty *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum _ns22__alert_info_certainty*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns22__alert_info_certainty, sizeof(enum _ns22__alert_info_certainty), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2_ns22__alert_info_certainty(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum _ns22__alert_info_certainty *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns22__alert_info_certainty, SOAP_TYPE__ns22__alert_info_certainty, sizeof(enum _ns22__alert_info_certainty), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum _ns22__alert_info_certainty * SOAP_FMAC4 soap_new__ns22__alert_info_certainty(struct soap *soap, int n)
{
	enum _ns22__alert_info_certainty *a = static_cast<enum _ns22__alert_info_certainty *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum _ns22__alert_info_certainty)));
	for (enum _ns22__alert_info_certainty *p = a; p && n--; ++p)
		soap_default__ns22__alert_info_certainty(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns22__alert_info_certainty(struct soap *soap, const enum _ns22__alert_info_certainty *a, const char *tag, const char *type)
{
	if (soap_out__ns22__alert_info_certainty(soap, tag ? tag : "ns22:alert-info-certainty", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum _ns22__alert_info_certainty * SOAP_FMAC4 soap_get__ns22__alert_info_certainty(struct soap *soap, enum _ns22__alert_info_certainty *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns22__alert_info_certainty(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes__ns22__alert_info_severity[] =
{	{ (LONG64)_ns22__alert_info_severity__Extreme, "Extreme" },
	{ (LONG64)_ns22__alert_info_severity__Severe, "Severe" },
	{ (LONG64)_ns22__alert_info_severity__Moderate, "Moderate" },
	{ (LONG64)_ns22__alert_info_severity__Minor, "Minor" },
	{ (LONG64)_ns22__alert_info_severity__Unknown, "Unknown" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap__ns22__alert_info_severity2s(struct soap *soap, enum _ns22__alert_info_severity n)
{
	const char *s = soap_code_str(soap_codes__ns22__alert_info_severity, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns22__alert_info_severity(struct soap *soap, const char *tag, int id, const enum _ns22__alert_info_severity *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns22__alert_info_severity), type) || soap_send(soap, soap__ns22__alert_info_severity2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2_ns22__alert_info_severity(struct soap *soap, const char *s, enum _ns22__alert_info_severity *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes__ns22__alert_info_severity, s);
	if (map)
		*a = (enum _ns22__alert_info_severity)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 4)
			return soap->error = SOAP_TYPE;
		*a = (enum _ns22__alert_info_severity)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum _ns22__alert_info_severity * SOAP_FMAC4 soap_in__ns22__alert_info_severity(struct soap *soap, const char *tag, enum _ns22__alert_info_severity *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum _ns22__alert_info_severity*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns22__alert_info_severity, sizeof(enum _ns22__alert_info_severity), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2_ns22__alert_info_severity(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum _ns22__alert_info_severity *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns22__alert_info_severity, SOAP_TYPE__ns22__alert_info_severity, sizeof(enum _ns22__alert_info_severity), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum _ns22__alert_info_severity * SOAP_FMAC4 soap_new__ns22__alert_info_severity(struct soap *soap, int n)
{
	enum _ns22__alert_info_severity *a = static_cast<enum _ns22__alert_info_severity *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum _ns22__alert_info_severity)));
	for (enum _ns22__alert_info_severity *p = a; p && n--; ++p)
		soap_default__ns22__alert_info_severity(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns22__alert_info_severity(struct soap *soap, const enum _ns22__alert_info_severity *a, const char *tag, const char *type)
{
	if (soap_out__ns22__alert_info_severity(soap, tag ? tag : "ns22:alert-info-severity", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum _ns22__alert_info_severity * SOAP_FMAC4 soap_get__ns22__alert_info_severity(struct soap *soap, enum _ns22__alert_info_severity *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns22__alert_info_severity(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes__ns22__alert_info_urgency[] =
{	{ (LONG64)_ns22__alert_info_urgency__Immediate, "Immediate" },
	{ (LONG64)_ns22__alert_info_urgency__Expected, "Expected" },
	{ (LONG64)_ns22__alert_info_urgency__Future, "Future" },
	{ (LONG64)_ns22__alert_info_urgency__Past, "Past" },
	{ (LONG64)_ns22__alert_info_urgency__Unknown, "Unknown" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap__ns22__alert_info_urgency2s(struct soap *soap, enum _ns22__alert_info_urgency n)
{
	const char *s = soap_code_str(soap_codes__ns22__alert_info_urgency, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns22__alert_info_urgency(struct soap *soap, const char *tag, int id, const enum _ns22__alert_info_urgency *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns22__alert_info_urgency), type) || soap_send(soap, soap__ns22__alert_info_urgency2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2_ns22__alert_info_urgency(struct soap *soap, const char *s, enum _ns22__alert_info_urgency *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes__ns22__alert_info_urgency, s);
	if (map)
		*a = (enum _ns22__alert_info_urgency)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 4)
			return soap->error = SOAP_TYPE;
		*a = (enum _ns22__alert_info_urgency)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum _ns22__alert_info_urgency * SOAP_FMAC4 soap_in__ns22__alert_info_urgency(struct soap *soap, const char *tag, enum _ns22__alert_info_urgency *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum _ns22__alert_info_urgency*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns22__alert_info_urgency, sizeof(enum _ns22__alert_info_urgency), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2_ns22__alert_info_urgency(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum _ns22__alert_info_urgency *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns22__alert_info_urgency, SOAP_TYPE__ns22__alert_info_urgency, sizeof(enum _ns22__alert_info_urgency), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum _ns22__alert_info_urgency * SOAP_FMAC4 soap_new__ns22__alert_info_urgency(struct soap *soap, int n)
{
	enum _ns22__alert_info_urgency *a = static_cast<enum _ns22__alert_info_urgency *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum _ns22__alert_info_urgency)));
	for (enum _ns22__alert_info_urgency *p = a; p && n--; ++p)
		soap_default__ns22__alert_info_urgency(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns22__alert_info_urgency(struct soap *soap, const enum _ns22__alert_info_urgency *a, const char *tag, const char *type)
{
	if (soap_out__ns22__alert_info_urgency(soap, tag ? tag : "ns22:alert-info-urgency", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum _ns22__alert_info_urgency * SOAP_FMAC4 soap_get__ns22__alert_info_urgency(struct soap *soap, enum _ns22__alert_info_urgency *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns22__alert_info_urgency(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes__ns22__alert_info_responseType[] =
{	{ (LONG64)_ns22__alert_info_responseType__Shelter, "Shelter" },
	{ (LONG64)_ns22__alert_info_responseType__Evacuate, "Evacuate" },
	{ (LONG64)_ns22__alert_info_responseType__Prepare, "Prepare" },
	{ (LONG64)_ns22__alert_info_responseType__Execute, "Execute" },
	{ (LONG64)_ns22__alert_info_responseType__Avoid, "Avoid" },
	{ (LONG64)_ns22__alert_info_responseType__Monitor, "Monitor" },
	{ (LONG64)_ns22__alert_info_responseType__Assess, "Assess" },
	{ (LONG64)_ns22__alert_info_responseType__AllClear, "AllClear" },
	{ (LONG64)_ns22__alert_info_responseType__None, "None" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap__ns22__alert_info_responseType2s(struct soap *soap, enum _ns22__alert_info_responseType n)
{
	const char *s = soap_code_str(soap_codes__ns22__alert_info_responseType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns22__alert_info_responseType(struct soap *soap, const char *tag, int id, const enum _ns22__alert_info_responseType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns22__alert_info_responseType), type) || soap_send(soap, soap__ns22__alert_info_responseType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2_ns22__alert_info_responseType(struct soap *soap, const char *s, enum _ns22__alert_info_responseType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes__ns22__alert_info_responseType, s);
	if (map)
		*a = (enum _ns22__alert_info_responseType)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 8)
			return soap->error = SOAP_TYPE;
		*a = (enum _ns22__alert_info_responseType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum _ns22__alert_info_responseType * SOAP_FMAC4 soap_in__ns22__alert_info_responseType(struct soap *soap, const char *tag, enum _ns22__alert_info_responseType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum _ns22__alert_info_responseType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns22__alert_info_responseType, sizeof(enum _ns22__alert_info_responseType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2_ns22__alert_info_responseType(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum _ns22__alert_info_responseType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns22__alert_info_responseType, SOAP_TYPE__ns22__alert_info_responseType, sizeof(enum _ns22__alert_info_responseType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum _ns22__alert_info_responseType * SOAP_FMAC4 soap_new__ns22__alert_info_responseType(struct soap *soap, int n)
{
	enum _ns22__alert_info_responseType *a = static_cast<enum _ns22__alert_info_responseType *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum _ns22__alert_info_responseType)));
	for (enum _ns22__alert_info_responseType *p = a; p && n--; ++p)
		soap_default__ns22__alert_info_responseType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns22__alert_info_responseType(struct soap *soap, const enum _ns22__alert_info_responseType *a, const char *tag, const char *type)
{
	if (soap_out__ns22__alert_info_responseType(soap, tag ? tag : "ns22:alert-info-responseType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum _ns22__alert_info_responseType * SOAP_FMAC4 soap_get__ns22__alert_info_responseType(struct soap *soap, enum _ns22__alert_info_responseType *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns22__alert_info_responseType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes__ns22__alert_info_category[] =
{	{ (LONG64)_ns22__alert_info_category__Geo, "Geo" },
	{ (LONG64)_ns22__alert_info_category__Met, "Met" },
	{ (LONG64)_ns22__alert_info_category__Safety, "Safety" },
	{ (LONG64)_ns22__alert_info_category__Security, "Security" },
	{ (LONG64)_ns22__alert_info_category__Rescue, "Rescue" },
	{ (LONG64)_ns22__alert_info_category__Fire, "Fire" },
	{ (LONG64)_ns22__alert_info_category__Health, "Health" },
	{ (LONG64)_ns22__alert_info_category__Env, "Env" },
	{ (LONG64)_ns22__alert_info_category__Transport, "Transport" },
	{ (LONG64)_ns22__alert_info_category__Infra, "Infra" },
	{ (LONG64)_ns22__alert_info_category__CBRNE, "CBRNE" },
	{ (LONG64)_ns22__alert_info_category__Other, "Other" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap__ns22__alert_info_category2s(struct soap *soap, enum _ns22__alert_info_category n)
{
	const char *s = soap_code_str(soap_codes__ns22__alert_info_category, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns22__alert_info_category(struct soap *soap, const char *tag, int id, const enum _ns22__alert_info_category *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns22__alert_info_category), type) || soap_send(soap, soap__ns22__alert_info_category2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2_ns22__alert_info_category(struct soap *soap, const char *s, enum _ns22__alert_info_category *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes__ns22__alert_info_category, s);
	if (map)
		*a = (enum _ns22__alert_info_category)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 11)
			return soap->error = SOAP_TYPE;
		*a = (enum _ns22__alert_info_category)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum _ns22__alert_info_category * SOAP_FMAC4 soap_in__ns22__alert_info_category(struct soap *soap, const char *tag, enum _ns22__alert_info_category *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum _ns22__alert_info_category*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns22__alert_info_category, sizeof(enum _ns22__alert_info_category), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2_ns22__alert_info_category(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum _ns22__alert_info_category *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns22__alert_info_category, SOAP_TYPE__ns22__alert_info_category, sizeof(enum _ns22__alert_info_category), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum _ns22__alert_info_category * SOAP_FMAC4 soap_new__ns22__alert_info_category(struct soap *soap, int n)
{
	enum _ns22__alert_info_category *a = static_cast<enum _ns22__alert_info_category *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum _ns22__alert_info_category)));
	for (enum _ns22__alert_info_category *p = a; p && n--; ++p)
		soap_default__ns22__alert_info_category(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns22__alert_info_category(struct soap *soap, const enum _ns22__alert_info_category *a, const char *tag, const char *type)
{
	if (soap_out__ns22__alert_info_category(soap, tag ? tag : "ns22:alert-info-category", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum _ns22__alert_info_category * SOAP_FMAC4 soap_get__ns22__alert_info_category(struct soap *soap, enum _ns22__alert_info_category *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns22__alert_info_category(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes__ns22__alert_scope[] =
{	{ (LONG64)_ns22__alert_scope__Public, "Public" },
	{ (LONG64)_ns22__alert_scope__Restricted, "Restricted" },
	{ (LONG64)_ns22__alert_scope__Private, "Private" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap__ns22__alert_scope2s(struct soap *soap, enum _ns22__alert_scope n)
{
	const char *s = soap_code_str(soap_codes__ns22__alert_scope, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns22__alert_scope(struct soap *soap, const char *tag, int id, const enum _ns22__alert_scope *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns22__alert_scope), type) || soap_send(soap, soap__ns22__alert_scope2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2_ns22__alert_scope(struct soap *soap, const char *s, enum _ns22__alert_scope *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes__ns22__alert_scope, s);
	if (map)
		*a = (enum _ns22__alert_scope)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 2)
			return soap->error = SOAP_TYPE;
		*a = (enum _ns22__alert_scope)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum _ns22__alert_scope * SOAP_FMAC4 soap_in__ns22__alert_scope(struct soap *soap, const char *tag, enum _ns22__alert_scope *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum _ns22__alert_scope*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns22__alert_scope, sizeof(enum _ns22__alert_scope), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2_ns22__alert_scope(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum _ns22__alert_scope *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns22__alert_scope, SOAP_TYPE__ns22__alert_scope, sizeof(enum _ns22__alert_scope), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum _ns22__alert_scope * SOAP_FMAC4 soap_new__ns22__alert_scope(struct soap *soap, int n)
{
	enum _ns22__alert_scope *a = static_cast<enum _ns22__alert_scope *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum _ns22__alert_scope)));
	for (enum _ns22__alert_scope *p = a; p && n--; ++p)
		soap_default__ns22__alert_scope(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns22__alert_scope(struct soap *soap, const enum _ns22__alert_scope *a, const char *tag, const char *type)
{
	if (soap_out__ns22__alert_scope(soap, tag ? tag : "ns22:alert-scope", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum _ns22__alert_scope * SOAP_FMAC4 soap_get__ns22__alert_scope(struct soap *soap, enum _ns22__alert_scope *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns22__alert_scope(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes__ns22__alert_msgType[] =
{	{ (LONG64)_ns22__alert_msgType__Alert, "Alert" },
	{ (LONG64)_ns22__alert_msgType__Update, "Update" },
	{ (LONG64)_ns22__alert_msgType__Cancel, "Cancel" },
	{ (LONG64)_ns22__alert_msgType__Ack, "Ack" },
	{ (LONG64)_ns22__alert_msgType__Error, "Error" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap__ns22__alert_msgType2s(struct soap *soap, enum _ns22__alert_msgType n)
{
	const char *s = soap_code_str(soap_codes__ns22__alert_msgType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns22__alert_msgType(struct soap *soap, const char *tag, int id, const enum _ns22__alert_msgType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns22__alert_msgType), type) || soap_send(soap, soap__ns22__alert_msgType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2_ns22__alert_msgType(struct soap *soap, const char *s, enum _ns22__alert_msgType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes__ns22__alert_msgType, s);
	if (map)
		*a = (enum _ns22__alert_msgType)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 4)
			return soap->error = SOAP_TYPE;
		*a = (enum _ns22__alert_msgType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum _ns22__alert_msgType * SOAP_FMAC4 soap_in__ns22__alert_msgType(struct soap *soap, const char *tag, enum _ns22__alert_msgType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum _ns22__alert_msgType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns22__alert_msgType, sizeof(enum _ns22__alert_msgType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2_ns22__alert_msgType(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum _ns22__alert_msgType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns22__alert_msgType, SOAP_TYPE__ns22__alert_msgType, sizeof(enum _ns22__alert_msgType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum _ns22__alert_msgType * SOAP_FMAC4 soap_new__ns22__alert_msgType(struct soap *soap, int n)
{
	enum _ns22__alert_msgType *a = static_cast<enum _ns22__alert_msgType *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum _ns22__alert_msgType)));
	for (enum _ns22__alert_msgType *p = a; p && n--; ++p)
		soap_default__ns22__alert_msgType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns22__alert_msgType(struct soap *soap, const enum _ns22__alert_msgType *a, const char *tag, const char *type)
{
	if (soap_out__ns22__alert_msgType(soap, tag ? tag : "ns22:alert-msgType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum _ns22__alert_msgType * SOAP_FMAC4 soap_get__ns22__alert_msgType(struct soap *soap, enum _ns22__alert_msgType *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns22__alert_msgType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes__ns22__alert_status[] =
{	{ (LONG64)_ns22__alert_status__Actual, "Actual" },
	{ (LONG64)_ns22__alert_status__Exercise, "Exercise" },
	{ (LONG64)_ns22__alert_status__System, "System" },
	{ (LONG64)_ns22__alert_status__Test, "Test" },
	{ (LONG64)_ns22__alert_status__Draft, "Draft" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap__ns22__alert_status2s(struct soap *soap, enum _ns22__alert_status n)
{
	const char *s = soap_code_str(soap_codes__ns22__alert_status, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns22__alert_status(struct soap *soap, const char *tag, int id, const enum _ns22__alert_status *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns22__alert_status), type) || soap_send(soap, soap__ns22__alert_status2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2_ns22__alert_status(struct soap *soap, const char *s, enum _ns22__alert_status *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes__ns22__alert_status, s);
	if (map)
		*a = (enum _ns22__alert_status)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 4)
			return soap->error = SOAP_TYPE;
		*a = (enum _ns22__alert_status)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum _ns22__alert_status * SOAP_FMAC4 soap_in__ns22__alert_status(struct soap *soap, const char *tag, enum _ns22__alert_status *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum _ns22__alert_status*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns22__alert_status, sizeof(enum _ns22__alert_status), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2_ns22__alert_status(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum _ns22__alert_status *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns22__alert_status, SOAP_TYPE__ns22__alert_status, sizeof(enum _ns22__alert_status), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum _ns22__alert_status * SOAP_FMAC4 soap_new__ns22__alert_status(struct soap *soap, int n)
{
	enum _ns22__alert_status *a = static_cast<enum _ns22__alert_status *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum _ns22__alert_status)));
	for (enum _ns22__alert_status *p = a; p && n--; ++p)
		soap_default__ns22__alert_status(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns22__alert_status(struct soap *soap, const enum _ns22__alert_status *a, const char *tag, const char *type)
{
	if (soap_out__ns22__alert_status(soap, tag ? tag : "ns22:alert-status", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum _ns22__alert_status * SOAP_FMAC4 soap_get__ns22__alert_status(struct soap *soap, enum _ns22__alert_status *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns22__alert_status(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns22__alert_info_area_geocode::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__string(soap, &this->_ns22__alert_info_area_geocode::valueName);
	soap_default_std__string(soap, &this->_ns22__alert_info_area_geocode::value);
}

void _ns22__alert_info_area_geocode::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_ns22__alert_info_area_geocode::valueName, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->_ns22__alert_info_area_geocode::valueName);
	soap_embedded(soap, &this->_ns22__alert_info_area_geocode::value, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->_ns22__alert_info_area_geocode::value);
#endif
}

int _ns22__alert_info_area_geocode::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns22__alert_info_area_geocode(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns22__alert_info_area_geocode(struct soap *soap, const char *tag, int id, const _ns22__alert_info_area_geocode *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns22__alert_info_area_geocode), type))
		return soap->error;
	if (soap_out_std__string(soap, "ns22:valueName", -1, &a->_ns22__alert_info_area_geocode::valueName, ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns22:value", -1, &a->_ns22__alert_info_area_geocode::value, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns22__alert_info_area_geocode::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns22__alert_info_area_geocode(soap, tag, this, type);
}

SOAP_FMAC3 _ns22__alert_info_area_geocode * SOAP_FMAC4 soap_in__ns22__alert_info_area_geocode(struct soap *soap, const char *tag, _ns22__alert_info_area_geocode *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns22__alert_info_area_geocode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns22__alert_info_area_geocode, sizeof(_ns22__alert_info_area_geocode), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns22__alert_info_area_geocode)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns22__alert_info_area_geocode *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_valueName1 = 1;
	size_t soap_flag_value1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_valueName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "ns22:valueName", &a->_ns22__alert_info_area_geocode::valueName, "xsd:string"))
				{	soap_flag_valueName1--;
					continue;
				}
			}
			if (soap_flag_value1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "ns22:value", &a->_ns22__alert_info_area_geocode::value, "xsd:string"))
				{	soap_flag_value1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_valueName1 > 0 || soap_flag_value1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns22__alert_info_area_geocode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns22__alert_info_area_geocode, SOAP_TYPE__ns22__alert_info_area_geocode, sizeof(_ns22__alert_info_area_geocode), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns22__alert_info_area_geocode * SOAP_FMAC2 soap_instantiate__ns22__alert_info_area_geocode(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns22__alert_info_area_geocode(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns22__alert_info_area_geocode *p;
	size_t k = sizeof(_ns22__alert_info_area_geocode);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns22__alert_info_area_geocode, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns22__alert_info_area_geocode);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns22__alert_info_area_geocode, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns22__alert_info_area_geocode location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns22__alert_info_area_geocode::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns22__alert_info_area_geocode(soap, tag ? tag : "ns22:alert-info-area-geocode", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns22__alert_info_area_geocode::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns22__alert_info_area_geocode(soap, this, tag, type);
}

SOAP_FMAC3 _ns22__alert_info_area_geocode * SOAP_FMAC4 soap_get__ns22__alert_info_area_geocode(struct soap *soap, _ns22__alert_info_area_geocode *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns22__alert_info_area_geocode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns22__alert_info_area::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__string(soap, &this->_ns22__alert_info_area::areaDesc);
	soap_default_std__vectorTemplateOfstd__string(soap, &this->_ns22__alert_info_area::polygon);
	soap_default_std__vectorTemplateOfstd__string(soap, &this->_ns22__alert_info_area::circle);
	soap_default_std__vectorTemplateOf_ns22__alert_info_area_geocode(soap, &this->_ns22__alert_info_area::geocode);
	this->_ns22__alert_info_area::altitude = NULL;
	this->_ns22__alert_info_area::ceiling = NULL;
}

void _ns22__alert_info_area::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_ns22__alert_info_area::areaDesc, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->_ns22__alert_info_area::areaDesc);
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->_ns22__alert_info_area::polygon);
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->_ns22__alert_info_area::circle);
	soap_serialize_std__vectorTemplateOf_ns22__alert_info_area_geocode(soap, &this->_ns22__alert_info_area::geocode);
	soap_serialize_PointerToxsd__decimal(soap, &this->_ns22__alert_info_area::altitude);
	soap_serialize_PointerToxsd__decimal(soap, &this->_ns22__alert_info_area::ceiling);
#endif
}

int _ns22__alert_info_area::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns22__alert_info_area(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns22__alert_info_area(struct soap *soap, const char *tag, int id, const _ns22__alert_info_area *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns22__alert_info_area), type))
		return soap->error;
	if (soap_out_std__string(soap, "ns22:areaDesc", -1, &a->_ns22__alert_info_area::areaDesc, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "ns22:polygon", -1, &a->_ns22__alert_info_area::polygon, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "ns22:circle", -1, &a->_ns22__alert_info_area::circle, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_ns22__alert_info_area_geocode(soap, "ns22:geocode", -1, &a->_ns22__alert_info_area::geocode, ""))
		return soap->error;
	if (soap_out_PointerToxsd__decimal(soap, "ns22:altitude", -1, &a->_ns22__alert_info_area::altitude, ""))
		return soap->error;
	if (soap_out_PointerToxsd__decimal(soap, "ns22:ceiling", -1, &a->_ns22__alert_info_area::ceiling, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns22__alert_info_area::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns22__alert_info_area(soap, tag, this, type);
}

SOAP_FMAC3 _ns22__alert_info_area * SOAP_FMAC4 soap_in__ns22__alert_info_area(struct soap *soap, const char *tag, _ns22__alert_info_area *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns22__alert_info_area*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns22__alert_info_area, sizeof(_ns22__alert_info_area), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns22__alert_info_area)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns22__alert_info_area *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_areaDesc1 = 1;
	size_t soap_flag_altitude1 = 1;
	size_t soap_flag_ceiling1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_areaDesc1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "ns22:areaDesc", &a->_ns22__alert_info_area::areaDesc, "xsd:string"))
				{	soap_flag_areaDesc1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfstd__string(soap, "ns22:polygon", &a->_ns22__alert_info_area::polygon, "xsd:string"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfstd__string(soap, "ns22:circle", &a->_ns22__alert_info_area::circle, "xsd:string"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_ns22__alert_info_area_geocode(soap, "ns22:geocode", &a->_ns22__alert_info_area::geocode, ""))
					continue;
			}
			if (soap_flag_altitude1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerToxsd__decimal(soap, "ns22:altitude", &a->_ns22__alert_info_area::altitude, "xsd:decimal"))
				{	soap_flag_altitude1--;
					continue;
				}
			}
			if (soap_flag_ceiling1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerToxsd__decimal(soap, "ns22:ceiling", &a->_ns22__alert_info_area::ceiling, "xsd:decimal"))
				{	soap_flag_ceiling1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_areaDesc1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns22__alert_info_area *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns22__alert_info_area, SOAP_TYPE__ns22__alert_info_area, sizeof(_ns22__alert_info_area), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns22__alert_info_area * SOAP_FMAC2 soap_instantiate__ns22__alert_info_area(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns22__alert_info_area(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns22__alert_info_area *p;
	size_t k = sizeof(_ns22__alert_info_area);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns22__alert_info_area, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns22__alert_info_area);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns22__alert_info_area, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns22__alert_info_area location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns22__alert_info_area::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns22__alert_info_area(soap, tag ? tag : "ns22:alert-info-area", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns22__alert_info_area::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns22__alert_info_area(soap, this, tag, type);
}

SOAP_FMAC3 _ns22__alert_info_area * SOAP_FMAC4 soap_get__ns22__alert_info_area(struct soap *soap, _ns22__alert_info_area *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns22__alert_info_area(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns22__alert_info_resource::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__string(soap, &this->_ns22__alert_info_resource::resourceDesc);
	soap_default_std__string(soap, &this->_ns22__alert_info_resource::mimeType);
	this->_ns22__alert_info_resource::size = NULL;
	this->_ns22__alert_info_resource::uri = NULL;
	this->_ns22__alert_info_resource::derefUri = NULL;
	this->_ns22__alert_info_resource::digest = NULL;
}

void _ns22__alert_info_resource::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_ns22__alert_info_resource::resourceDesc, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->_ns22__alert_info_resource::resourceDesc);
	soap_embedded(soap, &this->_ns22__alert_info_resource::mimeType, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->_ns22__alert_info_resource::mimeType);
	soap_serialize_PointerToxsd__integer(soap, &this->_ns22__alert_info_resource::size);
	soap_serialize_PointerToxsd__anyURI(soap, &this->_ns22__alert_info_resource::uri);
	soap_serialize_PointerTostd__string(soap, &this->_ns22__alert_info_resource::derefUri);
	soap_serialize_PointerTostd__string(soap, &this->_ns22__alert_info_resource::digest);
#endif
}

int _ns22__alert_info_resource::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns22__alert_info_resource(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns22__alert_info_resource(struct soap *soap, const char *tag, int id, const _ns22__alert_info_resource *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns22__alert_info_resource), type))
		return soap->error;
	if (soap_out_std__string(soap, "ns22:resourceDesc", -1, &a->_ns22__alert_info_resource::resourceDesc, ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns22:mimeType", -1, &a->_ns22__alert_info_resource::mimeType, ""))
		return soap->error;
	if (soap_out_PointerToxsd__integer(soap, "ns22:size", -1, &a->_ns22__alert_info_resource::size, ""))
		return soap->error;
	if (soap_out_PointerToxsd__anyURI(soap, "ns22:uri", -1, &a->_ns22__alert_info_resource::uri, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns22:derefUri", -1, &a->_ns22__alert_info_resource::derefUri, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns22:digest", -1, &a->_ns22__alert_info_resource::digest, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns22__alert_info_resource::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns22__alert_info_resource(soap, tag, this, type);
}

SOAP_FMAC3 _ns22__alert_info_resource * SOAP_FMAC4 soap_in__ns22__alert_info_resource(struct soap *soap, const char *tag, _ns22__alert_info_resource *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns22__alert_info_resource*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns22__alert_info_resource, sizeof(_ns22__alert_info_resource), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns22__alert_info_resource)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns22__alert_info_resource *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_resourceDesc1 = 1;
	size_t soap_flag_mimeType1 = 1;
	size_t soap_flag_size1 = 1;
	size_t soap_flag_uri1 = 1;
	size_t soap_flag_derefUri1 = 1;
	size_t soap_flag_digest1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_resourceDesc1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "ns22:resourceDesc", &a->_ns22__alert_info_resource::resourceDesc, "xsd:string"))
				{	soap_flag_resourceDesc1--;
					continue;
				}
			}
			if (soap_flag_mimeType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "ns22:mimeType", &a->_ns22__alert_info_resource::mimeType, "xsd:string"))
				{	soap_flag_mimeType1--;
					continue;
				}
			}
			if (soap_flag_size1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerToxsd__integer(soap, "ns22:size", &a->_ns22__alert_info_resource::size, "xsd:integer"))
				{	soap_flag_size1--;
					continue;
				}
			}
			if (soap_flag_uri1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerToxsd__anyURI(soap, "ns22:uri", &a->_ns22__alert_info_resource::uri, "xsd:anyURI"))
				{	soap_flag_uri1--;
					continue;
				}
			}
			if (soap_flag_derefUri1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns22:derefUri", &a->_ns22__alert_info_resource::derefUri, "xsd:string"))
				{	soap_flag_derefUri1--;
					continue;
				}
			}
			if (soap_flag_digest1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns22:digest", &a->_ns22__alert_info_resource::digest, "xsd:string"))
				{	soap_flag_digest1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_resourceDesc1 > 0 || soap_flag_mimeType1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns22__alert_info_resource *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns22__alert_info_resource, SOAP_TYPE__ns22__alert_info_resource, sizeof(_ns22__alert_info_resource), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns22__alert_info_resource * SOAP_FMAC2 soap_instantiate__ns22__alert_info_resource(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns22__alert_info_resource(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns22__alert_info_resource *p;
	size_t k = sizeof(_ns22__alert_info_resource);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns22__alert_info_resource, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns22__alert_info_resource);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns22__alert_info_resource, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns22__alert_info_resource location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns22__alert_info_resource::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns22__alert_info_resource(soap, tag ? tag : "ns22:alert-info-resource", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns22__alert_info_resource::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns22__alert_info_resource(soap, this, tag, type);
}

SOAP_FMAC3 _ns22__alert_info_resource * SOAP_FMAC4 soap_get__ns22__alert_info_resource(struct soap *soap, _ns22__alert_info_resource *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns22__alert_info_resource(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns22__alert_info_parameter::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__string(soap, &this->_ns22__alert_info_parameter::valueName);
	soap_default_std__string(soap, &this->_ns22__alert_info_parameter::value);
}

void _ns22__alert_info_parameter::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_ns22__alert_info_parameter::valueName, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->_ns22__alert_info_parameter::valueName);
	soap_embedded(soap, &this->_ns22__alert_info_parameter::value, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->_ns22__alert_info_parameter::value);
#endif
}

int _ns22__alert_info_parameter::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns22__alert_info_parameter(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns22__alert_info_parameter(struct soap *soap, const char *tag, int id, const _ns22__alert_info_parameter *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns22__alert_info_parameter), type))
		return soap->error;
	if (soap_out_std__string(soap, "ns22:valueName", -1, &a->_ns22__alert_info_parameter::valueName, ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns22:value", -1, &a->_ns22__alert_info_parameter::value, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns22__alert_info_parameter::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns22__alert_info_parameter(soap, tag, this, type);
}

SOAP_FMAC3 _ns22__alert_info_parameter * SOAP_FMAC4 soap_in__ns22__alert_info_parameter(struct soap *soap, const char *tag, _ns22__alert_info_parameter *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns22__alert_info_parameter*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns22__alert_info_parameter, sizeof(_ns22__alert_info_parameter), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns22__alert_info_parameter)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns22__alert_info_parameter *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_valueName1 = 1;
	size_t soap_flag_value1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_valueName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "ns22:valueName", &a->_ns22__alert_info_parameter::valueName, "xsd:string"))
				{	soap_flag_valueName1--;
					continue;
				}
			}
			if (soap_flag_value1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "ns22:value", &a->_ns22__alert_info_parameter::value, "xsd:string"))
				{	soap_flag_value1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_valueName1 > 0 || soap_flag_value1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns22__alert_info_parameter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns22__alert_info_parameter, SOAP_TYPE__ns22__alert_info_parameter, sizeof(_ns22__alert_info_parameter), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns22__alert_info_parameter * SOAP_FMAC2 soap_instantiate__ns22__alert_info_parameter(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns22__alert_info_parameter(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns22__alert_info_parameter *p;
	size_t k = sizeof(_ns22__alert_info_parameter);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns22__alert_info_parameter, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns22__alert_info_parameter);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns22__alert_info_parameter, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns22__alert_info_parameter location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns22__alert_info_parameter::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns22__alert_info_parameter(soap, tag ? tag : "ns22:alert-info-parameter", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns22__alert_info_parameter::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns22__alert_info_parameter(soap, this, tag, type);
}

SOAP_FMAC3 _ns22__alert_info_parameter * SOAP_FMAC4 soap_get__ns22__alert_info_parameter(struct soap *soap, _ns22__alert_info_parameter *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns22__alert_info_parameter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns22__alert_info_eventCode::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__string(soap, &this->_ns22__alert_info_eventCode::valueName);
	soap_default_std__string(soap, &this->_ns22__alert_info_eventCode::value);
}

void _ns22__alert_info_eventCode::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_ns22__alert_info_eventCode::valueName, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->_ns22__alert_info_eventCode::valueName);
	soap_embedded(soap, &this->_ns22__alert_info_eventCode::value, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->_ns22__alert_info_eventCode::value);
#endif
}

int _ns22__alert_info_eventCode::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns22__alert_info_eventCode(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns22__alert_info_eventCode(struct soap *soap, const char *tag, int id, const _ns22__alert_info_eventCode *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns22__alert_info_eventCode), type))
		return soap->error;
	if (soap_out_std__string(soap, "ns22:valueName", -1, &a->_ns22__alert_info_eventCode::valueName, ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns22:value", -1, &a->_ns22__alert_info_eventCode::value, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns22__alert_info_eventCode::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns22__alert_info_eventCode(soap, tag, this, type);
}

SOAP_FMAC3 _ns22__alert_info_eventCode * SOAP_FMAC4 soap_in__ns22__alert_info_eventCode(struct soap *soap, const char *tag, _ns22__alert_info_eventCode *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns22__alert_info_eventCode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns22__alert_info_eventCode, sizeof(_ns22__alert_info_eventCode), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns22__alert_info_eventCode)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns22__alert_info_eventCode *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_valueName1 = 1;
	size_t soap_flag_value1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_valueName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "ns22:valueName", &a->_ns22__alert_info_eventCode::valueName, "xsd:string"))
				{	soap_flag_valueName1--;
					continue;
				}
			}
			if (soap_flag_value1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "ns22:value", &a->_ns22__alert_info_eventCode::value, "xsd:string"))
				{	soap_flag_value1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_valueName1 > 0 || soap_flag_value1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns22__alert_info_eventCode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns22__alert_info_eventCode, SOAP_TYPE__ns22__alert_info_eventCode, sizeof(_ns22__alert_info_eventCode), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns22__alert_info_eventCode * SOAP_FMAC2 soap_instantiate__ns22__alert_info_eventCode(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns22__alert_info_eventCode(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns22__alert_info_eventCode *p;
	size_t k = sizeof(_ns22__alert_info_eventCode);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns22__alert_info_eventCode, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns22__alert_info_eventCode);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns22__alert_info_eventCode, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns22__alert_info_eventCode location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns22__alert_info_eventCode::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns22__alert_info_eventCode(soap, tag ? tag : "ns22:alert-info-eventCode", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns22__alert_info_eventCode::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns22__alert_info_eventCode(soap, this, tag, type);
}

SOAP_FMAC3 _ns22__alert_info_eventCode * SOAP_FMAC4 soap_get__ns22__alert_info_eventCode(struct soap *soap, _ns22__alert_info_eventCode *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns22__alert_info_eventCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns22__alert_info::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->_ns22__alert_info::language = NULL;
	soap_default_std__vectorTemplateOf_ns22__alert_info_category(soap, &this->_ns22__alert_info::category);
	soap_default_std__string(soap, &this->_ns22__alert_info::event);
	soap_default_std__vectorTemplateOf_ns22__alert_info_responseType(soap, &this->_ns22__alert_info::responseType);
	soap_default__ns22__alert_info_urgency(soap, &this->_ns22__alert_info::urgency);
	soap_default__ns22__alert_info_severity(soap, &this->_ns22__alert_info::severity);
	soap_default__ns22__alert_info_certainty(soap, &this->_ns22__alert_info::certainty);
	this->_ns22__alert_info::audience = NULL;
	soap_default_std__vectorTemplateOf_ns22__alert_info_eventCode(soap, &this->_ns22__alert_info::eventCode);
	this->_ns22__alert_info::effective = NULL;
	this->_ns22__alert_info::onset = NULL;
	this->_ns22__alert_info::expires = NULL;
	this->_ns22__alert_info::senderName = NULL;
	this->_ns22__alert_info::headline = NULL;
	this->_ns22__alert_info::description = NULL;
	this->_ns22__alert_info::instruction = NULL;
	this->_ns22__alert_info::web = NULL;
	this->_ns22__alert_info::contact = NULL;
	soap_default_std__vectorTemplateOf_ns22__alert_info_parameter(soap, &this->_ns22__alert_info::parameter);
	soap_default_std__vectorTemplateOf_ns22__alert_info_resource(soap, &this->_ns22__alert_info::resource);
	soap_default_std__vectorTemplateOf_ns22__alert_info_area(soap, &this->_ns22__alert_info::area);
}

void _ns22__alert_info::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToxsd__language(soap, &this->_ns22__alert_info::language);
	soap_serialize_std__vectorTemplateOf_ns22__alert_info_category(soap, &this->_ns22__alert_info::category);
	soap_embedded(soap, &this->_ns22__alert_info::event, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->_ns22__alert_info::event);
	soap_serialize_std__vectorTemplateOf_ns22__alert_info_responseType(soap, &this->_ns22__alert_info::responseType);
	soap_embedded(soap, &this->_ns22__alert_info::urgency, SOAP_TYPE__ns22__alert_info_urgency);
	soap_embedded(soap, &this->_ns22__alert_info::severity, SOAP_TYPE__ns22__alert_info_severity);
	soap_embedded(soap, &this->_ns22__alert_info::certainty, SOAP_TYPE__ns22__alert_info_certainty);
	soap_serialize_PointerTostd__string(soap, &this->_ns22__alert_info::audience);
	soap_serialize_std__vectorTemplateOf_ns22__alert_info_eventCode(soap, &this->_ns22__alert_info::eventCode);
	soap_serialize_PointerTodateTime(soap, &this->_ns22__alert_info::effective);
	soap_serialize_PointerTodateTime(soap, &this->_ns22__alert_info::onset);
	soap_serialize_PointerTodateTime(soap, &this->_ns22__alert_info::expires);
	soap_serialize_PointerTostd__string(soap, &this->_ns22__alert_info::senderName);
	soap_serialize_PointerTostd__string(soap, &this->_ns22__alert_info::headline);
	soap_serialize_PointerTostd__string(soap, &this->_ns22__alert_info::description);
	soap_serialize_PointerTostd__string(soap, &this->_ns22__alert_info::instruction);
	soap_serialize_PointerToxsd__anyURI(soap, &this->_ns22__alert_info::web);
	soap_serialize_PointerTostd__string(soap, &this->_ns22__alert_info::contact);
	soap_serialize_std__vectorTemplateOf_ns22__alert_info_parameter(soap, &this->_ns22__alert_info::parameter);
	soap_serialize_std__vectorTemplateOf_ns22__alert_info_resource(soap, &this->_ns22__alert_info::resource);
	soap_serialize_std__vectorTemplateOf_ns22__alert_info_area(soap, &this->_ns22__alert_info::area);
#endif
}

int _ns22__alert_info::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns22__alert_info(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns22__alert_info(struct soap *soap, const char *tag, int id, const _ns22__alert_info *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns22__alert_info), type))
		return soap->error;
	if (soap_out_PointerToxsd__language(soap, "ns22:language", -1, &a->_ns22__alert_info::language, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_ns22__alert_info_category(soap, "ns22:category", -1, &a->_ns22__alert_info::category, ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns22:event", -1, &a->_ns22__alert_info::event, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_ns22__alert_info_responseType(soap, "ns22:responseType", -1, &a->_ns22__alert_info::responseType, ""))
		return soap->error;
	if (soap_out__ns22__alert_info_urgency(soap, "ns22:urgency", -1, &a->_ns22__alert_info::urgency, ""))
		return soap->error;
	if (soap_out__ns22__alert_info_severity(soap, "ns22:severity", -1, &a->_ns22__alert_info::severity, ""))
		return soap->error;
	if (soap_out__ns22__alert_info_certainty(soap, "ns22:certainty", -1, &a->_ns22__alert_info::certainty, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns22:audience", -1, &a->_ns22__alert_info::audience, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_ns22__alert_info_eventCode(soap, "ns22:eventCode", -1, &a->_ns22__alert_info::eventCode, ""))
		return soap->error;
	if (soap_out_PointerTodateTime(soap, "ns22:effective", -1, &a->_ns22__alert_info::effective, ""))
		return soap->error;
	if (soap_out_PointerTodateTime(soap, "ns22:onset", -1, &a->_ns22__alert_info::onset, ""))
		return soap->error;
	if (soap_out_PointerTodateTime(soap, "ns22:expires", -1, &a->_ns22__alert_info::expires, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns22:senderName", -1, &a->_ns22__alert_info::senderName, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns22:headline", -1, &a->_ns22__alert_info::headline, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns22:description", -1, &a->_ns22__alert_info::description, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns22:instruction", -1, &a->_ns22__alert_info::instruction, ""))
		return soap->error;
	if (soap_out_PointerToxsd__anyURI(soap, "ns22:web", -1, &a->_ns22__alert_info::web, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns22:contact", -1, &a->_ns22__alert_info::contact, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_ns22__alert_info_parameter(soap, "ns22:parameter", -1, &a->_ns22__alert_info::parameter, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_ns22__alert_info_resource(soap, "ns22:resource", -1, &a->_ns22__alert_info::resource, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_ns22__alert_info_area(soap, "ns22:area", -1, &a->_ns22__alert_info::area, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns22__alert_info::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns22__alert_info(soap, tag, this, type);
}

SOAP_FMAC3 _ns22__alert_info * SOAP_FMAC4 soap_in__ns22__alert_info(struct soap *soap, const char *tag, _ns22__alert_info *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns22__alert_info*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns22__alert_info, sizeof(_ns22__alert_info), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns22__alert_info)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns22__alert_info *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_language1 = 1;
	size_t soap_flag_event1 = 1;
	size_t soap_flag_urgency1 = 1;
	size_t soap_flag_severity1 = 1;
	size_t soap_flag_certainty1 = 1;
	size_t soap_flag_audience1 = 1;
	size_t soap_flag_effective1 = 1;
	size_t soap_flag_onset1 = 1;
	size_t soap_flag_expires1 = 1;
	size_t soap_flag_senderName1 = 1;
	size_t soap_flag_headline1 = 1;
	size_t soap_flag_description1 = 1;
	size_t soap_flag_instruction1 = 1;
	size_t soap_flag_web1 = 1;
	size_t soap_flag_contact1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_language1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerToxsd__language(soap, "ns22:language", &a->_ns22__alert_info::language, "xsd:language"))
				{	soap_flag_language1--;
					if (*soap->href != '#' && a->_ns22__alert_info::language && a->_ns22__alert_info::language->empty())
						*a->_ns22__alert_info::language = "en-US";
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_ns22__alert_info_category(soap, "ns22:category", &a->_ns22__alert_info::category, "ns22:alert-info-category"))
					continue;
			}
			if (soap_flag_event1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "ns22:event", &a->_ns22__alert_info::event, "xsd:string"))
				{	soap_flag_event1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_ns22__alert_info_responseType(soap, "ns22:responseType", &a->_ns22__alert_info::responseType, "ns22:alert-info-responseType"))
					continue;
			}
			if (soap_flag_urgency1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in__ns22__alert_info_urgency(soap, "ns22:urgency", &a->_ns22__alert_info::urgency, "ns22:alert-info-urgency"))
				{	soap_flag_urgency1--;
					continue;
				}
			}
			if (soap_flag_severity1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in__ns22__alert_info_severity(soap, "ns22:severity", &a->_ns22__alert_info::severity, "ns22:alert-info-severity"))
				{	soap_flag_severity1--;
					continue;
				}
			}
			if (soap_flag_certainty1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in__ns22__alert_info_certainty(soap, "ns22:certainty", &a->_ns22__alert_info::certainty, "ns22:alert-info-certainty"))
				{	soap_flag_certainty1--;
					continue;
				}
			}
			if (soap_flag_audience1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns22:audience", &a->_ns22__alert_info::audience, "xsd:string"))
				{	soap_flag_audience1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_ns22__alert_info_eventCode(soap, "ns22:eventCode", &a->_ns22__alert_info::eventCode, ""))
					continue;
			}
			if (soap_flag_effective1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTodateTime(soap, "ns22:effective", &a->_ns22__alert_info::effective, "xsd:dateTime"))
				{	soap_flag_effective1--;
					continue;
				}
			}
			if (soap_flag_onset1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTodateTime(soap, "ns22:onset", &a->_ns22__alert_info::onset, "xsd:dateTime"))
				{	soap_flag_onset1--;
					continue;
				}
			}
			if (soap_flag_expires1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTodateTime(soap, "ns22:expires", &a->_ns22__alert_info::expires, "xsd:dateTime"))
				{	soap_flag_expires1--;
					continue;
				}
			}
			if (soap_flag_senderName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns22:senderName", &a->_ns22__alert_info::senderName, "xsd:string"))
				{	soap_flag_senderName1--;
					continue;
				}
			}
			if (soap_flag_headline1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns22:headline", &a->_ns22__alert_info::headline, "xsd:string"))
				{	soap_flag_headline1--;
					continue;
				}
			}
			if (soap_flag_description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns22:description", &a->_ns22__alert_info::description, "xsd:string"))
				{	soap_flag_description1--;
					continue;
				}
			}
			if (soap_flag_instruction1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns22:instruction", &a->_ns22__alert_info::instruction, "xsd:string"))
				{	soap_flag_instruction1--;
					continue;
				}
			}
			if (soap_flag_web1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerToxsd__anyURI(soap, "ns22:web", &a->_ns22__alert_info::web, "xsd:anyURI"))
				{	soap_flag_web1--;
					continue;
				}
			}
			if (soap_flag_contact1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns22:contact", &a->_ns22__alert_info::contact, "xsd:string"))
				{	soap_flag_contact1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_ns22__alert_info_parameter(soap, "ns22:parameter", &a->_ns22__alert_info::parameter, ""))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_ns22__alert_info_resource(soap, "ns22:resource", &a->_ns22__alert_info::resource, ""))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_ns22__alert_info_area(soap, "ns22:area", &a->_ns22__alert_info::area, ""))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->_ns22__alert_info::category.size() < 1 || soap_flag_event1 > 0 || soap_flag_urgency1 > 0 || soap_flag_severity1 > 0 || soap_flag_certainty1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns22__alert_info *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns22__alert_info, SOAP_TYPE__ns22__alert_info, sizeof(_ns22__alert_info), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns22__alert_info * SOAP_FMAC2 soap_instantiate__ns22__alert_info(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns22__alert_info(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns22__alert_info *p;
	size_t k = sizeof(_ns22__alert_info);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns22__alert_info, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns22__alert_info);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns22__alert_info, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns22__alert_info location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns22__alert_info::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns22__alert_info(soap, tag ? tag : "ns22:alert-info", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns22__alert_info::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns22__alert_info(soap, this, tag, type);
}

SOAP_FMAC3 _ns22__alert_info * SOAP_FMAC4 soap_get__ns22__alert_info(struct soap *soap, _ns22__alert_info *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns22__alert_info(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__CAPHeaderTypeDef::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__CAPHeaderTypeDef::logonUser = NULL;
	this->_ns1__CAPHeaderTypeDef::logonCogId = NULL;
}

void _ns1__CAPHeaderTypeDef::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__CAPHeaderTypeDef::logonUser);
	soap_serialize_PointerToint(soap, &this->_ns1__CAPHeaderTypeDef::logonCogId);
#endif
}

int _ns1__CAPHeaderTypeDef::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__CAPHeaderTypeDef(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__CAPHeaderTypeDef(struct soap *soap, const char *tag, int id, const _ns1__CAPHeaderTypeDef *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__CAPHeaderTypeDef), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:logonUser", -1, &a->_ns1__CAPHeaderTypeDef::logonUser, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns1:logonCogId", -1, &a->_ns1__CAPHeaderTypeDef::logonCogId, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__CAPHeaderTypeDef::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns1__CAPHeaderTypeDef(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__CAPHeaderTypeDef * SOAP_FMAC4 soap_in__ns1__CAPHeaderTypeDef(struct soap *soap, const char *tag, _ns1__CAPHeaderTypeDef *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__CAPHeaderTypeDef*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__CAPHeaderTypeDef, sizeof(_ns1__CAPHeaderTypeDef), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__CAPHeaderTypeDef)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__CAPHeaderTypeDef *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_logonUser1 = 1;
	size_t soap_flag_logonCogId1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_logonUser1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:logonUser", &a->_ns1__CAPHeaderTypeDef::logonUser, "xsd:string"))
				{	soap_flag_logonUser1--;
					continue;
				}
			}
			if (soap_flag_logonCogId1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToint(soap, "ns1:logonCogId", &a->_ns1__CAPHeaderTypeDef::logonCogId, "xsd:int"))
				{	soap_flag_logonCogId1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__CAPHeaderTypeDef *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__CAPHeaderTypeDef, SOAP_TYPE__ns1__CAPHeaderTypeDef, sizeof(_ns1__CAPHeaderTypeDef), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__CAPHeaderTypeDef * SOAP_FMAC2 soap_instantiate__ns1__CAPHeaderTypeDef(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__CAPHeaderTypeDef(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__CAPHeaderTypeDef *p;
	size_t k = sizeof(_ns1__CAPHeaderTypeDef);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__CAPHeaderTypeDef, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__CAPHeaderTypeDef);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__CAPHeaderTypeDef, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__CAPHeaderTypeDef location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__CAPHeaderTypeDef::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__CAPHeaderTypeDef(soap, tag ? tag : "ns1:CAPHeaderTypeDef", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__CAPHeaderTypeDef::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__CAPHeaderTypeDef(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__CAPHeaderTypeDef * SOAP_FMAC4 soap_get__ns1__CAPHeaderTypeDef(struct soap *soap, _ns1__CAPHeaderTypeDef *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__CAPHeaderTypeDef(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__messageResponseTypeDef::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTo_ns22__alert(soap, &this->_ns1__messageResponseTypeDef::ns22__alert);
}

void _ns1__messageResponseTypeDef::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTo_ns22__alert(soap, &this->_ns1__messageResponseTypeDef::ns22__alert);
#endif
}

int _ns1__messageResponseTypeDef::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__messageResponseTypeDef(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__messageResponseTypeDef(struct soap *soap, const char *tag, int id, const _ns1__messageResponseTypeDef *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__messageResponseTypeDef), type))
		return soap->error;
	soap_element_result(soap, "ns22:alert");
	if (soap_out_std__vectorTemplateOfPointerTo_ns22__alert(soap, "ns22:alert", -1, &a->_ns1__messageResponseTypeDef::ns22__alert, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__messageResponseTypeDef::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns1__messageResponseTypeDef(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__messageResponseTypeDef * SOAP_FMAC4 soap_in__ns1__messageResponseTypeDef(struct soap *soap, const char *tag, _ns1__messageResponseTypeDef *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__messageResponseTypeDef*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__messageResponseTypeDef, sizeof(_ns1__messageResponseTypeDef), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__messageResponseTypeDef)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__messageResponseTypeDef *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTo_ns22__alert(soap, "ns22:alert", &a->_ns1__messageResponseTypeDef::ns22__alert, ""))
					continue;
			}
			soap_check_result(soap, "ns22:alert");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__messageResponseTypeDef *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__messageResponseTypeDef, SOAP_TYPE__ns1__messageResponseTypeDef, sizeof(_ns1__messageResponseTypeDef), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__messageResponseTypeDef * SOAP_FMAC2 soap_instantiate__ns1__messageResponseTypeDef(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__messageResponseTypeDef(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__messageResponseTypeDef *p;
	size_t k = sizeof(_ns1__messageResponseTypeDef);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__messageResponseTypeDef, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__messageResponseTypeDef);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__messageResponseTypeDef, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__messageResponseTypeDef location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__messageResponseTypeDef::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__messageResponseTypeDef(soap, tag ? tag : "ns1:messageResponseTypeDef", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__messageResponseTypeDef::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__messageResponseTypeDef(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__messageResponseTypeDef * SOAP_FMAC4 soap_get__ns1__messageResponseTypeDef(struct soap *soap, _ns1__messageResponseTypeDef *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__messageResponseTypeDef(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__postCAPResponseTypeDef::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__postCAPResponseTypeDef::postCAPReturn = NULL;
}

void _ns1__postCAPResponseTypeDef::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__postCAPResponseTypeDef::postCAPReturn);
#endif
}

int _ns1__postCAPResponseTypeDef::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__postCAPResponseTypeDef(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__postCAPResponseTypeDef(struct soap *soap, const char *tag, int id, const _ns1__postCAPResponseTypeDef *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__postCAPResponseTypeDef), type))
		return soap->error;
	if (a->postCAPReturn)
		soap_element_result(soap, "ns1:postCAPReturn");
	if (!a->_ns1__postCAPResponseTypeDef::postCAPReturn)
	{	if (soap_element_nil(soap, "ns1:postCAPReturn"))
			return soap->error;
	}
	else if (soap_out_PointerTostd__string(soap, "ns1:postCAPReturn", -1, &a->_ns1__postCAPResponseTypeDef::postCAPReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__postCAPResponseTypeDef::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns1__postCAPResponseTypeDef(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__postCAPResponseTypeDef * SOAP_FMAC4 soap_in__ns1__postCAPResponseTypeDef(struct soap *soap, const char *tag, _ns1__postCAPResponseTypeDef *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__postCAPResponseTypeDef*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__postCAPResponseTypeDef, sizeof(_ns1__postCAPResponseTypeDef), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__postCAPResponseTypeDef)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__postCAPResponseTypeDef *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_postCAPReturn1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_postCAPReturn1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:postCAPReturn", &a->_ns1__postCAPResponseTypeDef::postCAPReturn, "xsd:string"))
				{	soap_flag_postCAPReturn1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:postCAPReturn");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_postCAPReturn1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__postCAPResponseTypeDef *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__postCAPResponseTypeDef, SOAP_TYPE__ns1__postCAPResponseTypeDef, sizeof(_ns1__postCAPResponseTypeDef), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__postCAPResponseTypeDef * SOAP_FMAC2 soap_instantiate__ns1__postCAPResponseTypeDef(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__postCAPResponseTypeDef(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__postCAPResponseTypeDef *p;
	size_t k = sizeof(_ns1__postCAPResponseTypeDef);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__postCAPResponseTypeDef, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__postCAPResponseTypeDef);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__postCAPResponseTypeDef, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__postCAPResponseTypeDef location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__postCAPResponseTypeDef::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__postCAPResponseTypeDef(soap, tag ? tag : "ns1:postCAPResponseTypeDef", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__postCAPResponseTypeDef::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__postCAPResponseTypeDef(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__postCAPResponseTypeDef * SOAP_FMAC4 soap_get__ns1__postCAPResponseTypeDef(struct soap *soap, _ns1__postCAPResponseTypeDef *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__postCAPResponseTypeDef(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__CAPServiceException::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__CAPServiceException::errorCode = NULL;
	this->_ns1__CAPServiceException::message = NULL;
}

void _ns1__CAPServiceException::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__CAPServiceException::errorCode);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__CAPServiceException::message);
#endif
}

int _ns1__CAPServiceException::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__CAPServiceException(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__CAPServiceException(struct soap *soap, const char *tag, int id, const _ns1__CAPServiceException *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__CAPServiceException), type))
		return soap->error;
	if (!a->_ns1__CAPServiceException::errorCode)
	{	if (soap_element_nil(soap, "ns1:errorCode"))
			return soap->error;
	}
	else if (soap_out_PointerTostd__string(soap, "ns1:errorCode", -1, &a->_ns1__CAPServiceException::errorCode, ""))
		return soap->error;
	if (!a->_ns1__CAPServiceException::message)
	{	if (soap_element_nil(soap, "ns1:message"))
			return soap->error;
	}
	else if (soap_out_PointerTostd__string(soap, "ns1:message", -1, &a->_ns1__CAPServiceException::message, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__CAPServiceException::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns1__CAPServiceException(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__CAPServiceException * SOAP_FMAC4 soap_in__ns1__CAPServiceException(struct soap *soap, const char *tag, _ns1__CAPServiceException *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__CAPServiceException*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__CAPServiceException, sizeof(_ns1__CAPServiceException), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__CAPServiceException)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__CAPServiceException *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_errorCode1 = 1;
	size_t soap_flag_message1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_errorCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:errorCode", &a->_ns1__CAPServiceException::errorCode, "xsd:string"))
				{	soap_flag_errorCode1--;
					continue;
				}
			}
			if (soap_flag_message1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:message", &a->_ns1__CAPServiceException::message, "xsd:string"))
				{	soap_flag_message1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_errorCode1 > 0 || soap_flag_message1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__CAPServiceException *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__CAPServiceException, SOAP_TYPE__ns1__CAPServiceException, sizeof(_ns1__CAPServiceException), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__CAPServiceException * SOAP_FMAC2 soap_instantiate__ns1__CAPServiceException(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__CAPServiceException(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__CAPServiceException *p;
	size_t k = sizeof(_ns1__CAPServiceException);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__CAPServiceException, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__CAPServiceException);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__CAPServiceException, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__CAPServiceException location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__CAPServiceException::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__CAPServiceException(soap, tag ? tag : "ns1:CAPServiceException", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__CAPServiceException::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__CAPServiceException(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__CAPServiceException * SOAP_FMAC4 soap_get__ns1__CAPServiceException(struct soap *soap, _ns1__CAPServiceException *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__CAPServiceException(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__postCAPRequestTypeDef::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__postCAPRequestTypeDef::ns22__alert = NULL;
}

void _ns1__postCAPRequestTypeDef::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns22__alert(soap, &this->_ns1__postCAPRequestTypeDef::ns22__alert);
#endif
}

int _ns1__postCAPRequestTypeDef::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__postCAPRequestTypeDef(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__postCAPRequestTypeDef(struct soap *soap, const char *tag, int id, const _ns1__postCAPRequestTypeDef *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__postCAPRequestTypeDef), type))
		return soap->error;
	if (!a->_ns1__postCAPRequestTypeDef::ns22__alert)
	{	if (soap_element_empty(soap, "ns22:alert"))
			return soap->error;
	}
	else if (soap_out_PointerTo_ns22__alert(soap, "ns22:alert", -1, &a->_ns1__postCAPRequestTypeDef::ns22__alert, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__postCAPRequestTypeDef::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns1__postCAPRequestTypeDef(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__postCAPRequestTypeDef * SOAP_FMAC4 soap_in__ns1__postCAPRequestTypeDef(struct soap *soap, const char *tag, _ns1__postCAPRequestTypeDef *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__postCAPRequestTypeDef*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__postCAPRequestTypeDef, sizeof(_ns1__postCAPRequestTypeDef), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__postCAPRequestTypeDef)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__postCAPRequestTypeDef *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ns22__alert1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns22__alert1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns22__alert(soap, "ns22:alert", &a->_ns1__postCAPRequestTypeDef::ns22__alert, ""))
				{	soap_flag_ns22__alert1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->_ns1__postCAPRequestTypeDef::ns22__alert))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__postCAPRequestTypeDef *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__postCAPRequestTypeDef, SOAP_TYPE__ns1__postCAPRequestTypeDef, sizeof(_ns1__postCAPRequestTypeDef), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__postCAPRequestTypeDef * SOAP_FMAC2 soap_instantiate__ns1__postCAPRequestTypeDef(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__postCAPRequestTypeDef(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__postCAPRequestTypeDef *p;
	size_t k = sizeof(_ns1__postCAPRequestTypeDef);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__postCAPRequestTypeDef, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__postCAPRequestTypeDef);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__postCAPRequestTypeDef, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__postCAPRequestTypeDef location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__postCAPRequestTypeDef::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__postCAPRequestTypeDef(soap, tag ? tag : "ns1:postCAPRequestTypeDef", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__postCAPRequestTypeDef::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__postCAPRequestTypeDef(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__postCAPRequestTypeDef * SOAP_FMAC4 soap_get__ns1__postCAPRequestTypeDef(struct soap *soap, _ns1__postCAPRequestTypeDef *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__postCAPRequestTypeDef(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns22__alert::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->_ns22__alert::identifier);
	soap_default_std__string(soap, &this->_ns22__alert::sender);
	soap_default_dateTime(soap, &this->_ns22__alert::sent);
	soap_default__ns22__alert_status(soap, &this->_ns22__alert::status);
	soap_default__ns22__alert_msgType(soap, &this->_ns22__alert::msgType);
	this->_ns22__alert::source = NULL;
	soap_default__ns22__alert_scope(soap, &this->_ns22__alert::scope);
	this->_ns22__alert::restriction = NULL;
	this->_ns22__alert::addresses = NULL;
	soap_default_std__vectorTemplateOfstd__string(soap, &this->_ns22__alert::code);
	this->_ns22__alert::note = NULL;
	this->_ns22__alert::references = NULL;
	this->_ns22__alert::incidents = NULL;
	soap_default_std__vectorTemplateOf_ns22__alert_info(soap, &this->_ns22__alert::info);
	soap_default_std__vectorTemplateOf_XML(soap, &this->_ns22__alert::__any);
}

void _ns22__alert::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_ns22__alert::identifier, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->_ns22__alert::identifier);
	soap_embedded(soap, &this->_ns22__alert::sender, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->_ns22__alert::sender);
	soap_embedded(soap, &this->_ns22__alert::sent, SOAP_TYPE_dateTime);
	soap_embedded(soap, &this->_ns22__alert::status, SOAP_TYPE__ns22__alert_status);
	soap_embedded(soap, &this->_ns22__alert::msgType, SOAP_TYPE__ns22__alert_msgType);
	soap_serialize_PointerTostd__string(soap, &this->_ns22__alert::source);
	soap_embedded(soap, &this->_ns22__alert::scope, SOAP_TYPE__ns22__alert_scope);
	soap_serialize_PointerTostd__string(soap, &this->_ns22__alert::restriction);
	soap_serialize_PointerTostd__string(soap, &this->_ns22__alert::addresses);
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->_ns22__alert::code);
	soap_serialize_PointerTostd__string(soap, &this->_ns22__alert::note);
	soap_serialize_PointerTostd__string(soap, &this->_ns22__alert::references);
	soap_serialize_PointerTostd__string(soap, &this->_ns22__alert::incidents);
	soap_serialize_std__vectorTemplateOf_ns22__alert_info(soap, &this->_ns22__alert::info);
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->_ns22__alert::__any);
#endif
}

int _ns22__alert::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns22__alert(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns22__alert(struct soap *soap, const char *tag, int id, const _ns22__alert *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns22__alert), type))
		return soap->error;
	if (soap_out_std__string(soap, "ns22:identifier", -1, &a->_ns22__alert::identifier, ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns22:sender", -1, &a->_ns22__alert::sender, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "ns22:sent", -1, &a->_ns22__alert::sent, ""))
		return soap->error;
	if (soap_out__ns22__alert_status(soap, "ns22:status", -1, &a->_ns22__alert::status, ""))
		return soap->error;
	if (soap_out__ns22__alert_msgType(soap, "ns22:msgType", -1, &a->_ns22__alert::msgType, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns22:source", -1, &a->_ns22__alert::source, ""))
		return soap->error;
	if (soap_out__ns22__alert_scope(soap, "ns22:scope", -1, &a->_ns22__alert::scope, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns22:restriction", -1, &a->_ns22__alert::restriction, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns22:addresses", -1, &a->_ns22__alert::addresses, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "ns22:code", -1, &a->_ns22__alert::code, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns22:note", -1, &a->_ns22__alert::note, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns22:references", -1, &a->_ns22__alert::references, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns22:incidents", -1, &a->_ns22__alert::incidents, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_ns22__alert_info(soap, "ns22:info", -1, &a->_ns22__alert::info, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->_ns22__alert::__any, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns22__alert::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns22__alert(soap, tag, this, type);
}

SOAP_FMAC3 _ns22__alert * SOAP_FMAC4 soap_in__ns22__alert(struct soap *soap, const char *tag, _ns22__alert *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns22__alert*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns22__alert, sizeof(_ns22__alert), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns22__alert)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns22__alert *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_identifier1 = 1;
	size_t soap_flag_sender1 = 1;
	size_t soap_flag_sent1 = 1;
	size_t soap_flag_status1 = 1;
	size_t soap_flag_msgType1 = 1;
	size_t soap_flag_source1 = 1;
	size_t soap_flag_scope1 = 1;
	size_t soap_flag_restriction1 = 1;
	size_t soap_flag_addresses1 = 1;
	size_t soap_flag_note1 = 1;
	size_t soap_flag_references1 = 1;
	size_t soap_flag_incidents1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_identifier1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "ns22:identifier", &a->_ns22__alert::identifier, "xsd:string"))
				{	soap_flag_identifier1--;
					continue;
				}
			}
			if (soap_flag_sender1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "ns22:sender", &a->_ns22__alert::sender, "xsd:string"))
				{	soap_flag_sender1--;
					continue;
				}
			}
			if (soap_flag_sent1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "ns22:sent", &a->_ns22__alert::sent, "xsd:dateTime"))
				{	soap_flag_sent1--;
					continue;
				}
			}
			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in__ns22__alert_status(soap, "ns22:status", &a->_ns22__alert::status, "ns22:alert-status"))
				{	soap_flag_status1--;
					continue;
				}
			}
			if (soap_flag_msgType1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in__ns22__alert_msgType(soap, "ns22:msgType", &a->_ns22__alert::msgType, "ns22:alert-msgType"))
				{	soap_flag_msgType1--;
					continue;
				}
			}
			if (soap_flag_source1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns22:source", &a->_ns22__alert::source, "xsd:string"))
				{	soap_flag_source1--;
					continue;
				}
			}
			if (soap_flag_scope1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in__ns22__alert_scope(soap, "ns22:scope", &a->_ns22__alert::scope, "ns22:alert-scope"))
				{	soap_flag_scope1--;
					continue;
				}
			}
			if (soap_flag_restriction1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns22:restriction", &a->_ns22__alert::restriction, "xsd:string"))
				{	soap_flag_restriction1--;
					continue;
				}
			}
			if (soap_flag_addresses1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns22:addresses", &a->_ns22__alert::addresses, "xsd:string"))
				{	soap_flag_addresses1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfstd__string(soap, "ns22:code", &a->_ns22__alert::code, "xsd:string"))
					continue;
			}
			if (soap_flag_note1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns22:note", &a->_ns22__alert::note, "xsd:string"))
				{	soap_flag_note1--;
					continue;
				}
			}
			if (soap_flag_references1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns22:references", &a->_ns22__alert::references, "xsd:string"))
				{	soap_flag_references1--;
					continue;
				}
			}
			if (soap_flag_incidents1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns22:incidents", &a->_ns22__alert::incidents, "xsd:string"))
				{	soap_flag_incidents1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_ns22__alert_info(soap, "ns22:info", &a->_ns22__alert::info, ""))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->_ns22__alert::__any, ""))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_identifier1 > 0 || soap_flag_sender1 > 0 || soap_flag_sent1 > 0 || soap_flag_status1 > 0 || soap_flag_msgType1 > 0 || soap_flag_scope1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns22__alert *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns22__alert, SOAP_TYPE__ns22__alert, sizeof(_ns22__alert), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns22__alert * SOAP_FMAC2 soap_instantiate__ns22__alert(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns22__alert(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns22__alert *p;
	size_t k = sizeof(_ns22__alert);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns22__alert, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns22__alert);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns22__alert, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns22__alert location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns22__alert::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns22__alert(soap, tag ? tag : "ns22:alert", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns22__alert::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns22__alert(soap, this, tag, type);
}

SOAP_FMAC3 _ns22__alert * SOAP_FMAC4 soap_get__ns22__alert(struct soap *soap, _ns22__alert *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns22__alert(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns3__parameterListItem::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns3__parameterListItem::parameterName = NULL;
	this->_ns3__parameterListItem::parameterValue = NULL;
	soap_default_std__vectorTemplateOfPointerTons3__subParameterListItem(soap, &this->_ns3__parameterListItem::subParaListItem);
}

void _ns3__parameterListItem::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns3__parameterListItem::parameterName);
	soap_serialize_PointerTostd__string(soap, &this->_ns3__parameterListItem::parameterValue);
	soap_serialize_std__vectorTemplateOfPointerTons3__subParameterListItem(soap, &this->_ns3__parameterListItem::subParaListItem);
#endif
}

int _ns3__parameterListItem::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__parameterListItem(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__parameterListItem(struct soap *soap, const char *tag, int id, const _ns3__parameterListItem *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__parameterListItem), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns3:parameterName", -1, &a->_ns3__parameterListItem::parameterName, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns3:parameterValue", -1, &a->_ns3__parameterListItem::parameterValue, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons3__subParameterListItem(soap, "ns3:subParaListItem", -1, &a->_ns3__parameterListItem::subParaListItem, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns3__parameterListItem::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns3__parameterListItem(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__parameterListItem * SOAP_FMAC4 soap_in__ns3__parameterListItem(struct soap *soap, const char *tag, _ns3__parameterListItem *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__parameterListItem*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__parameterListItem, sizeof(_ns3__parameterListItem), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns3__parameterListItem)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns3__parameterListItem *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_parameterName1 = 1;
	size_t soap_flag_parameterValue1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_parameterName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns3:parameterName", &a->_ns3__parameterListItem::parameterName, "xsd:string"))
				{	soap_flag_parameterName1--;
					continue;
				}
			}
			if (soap_flag_parameterValue1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns3:parameterValue", &a->_ns3__parameterListItem::parameterValue, "xsd:string"))
				{	soap_flag_parameterValue1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons3__subParameterListItem(soap, "ns3:subParaListItem", &a->_ns3__parameterListItem::subParaListItem, "ns3:subParameterListItem"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__parameterListItem *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__parameterListItem, SOAP_TYPE__ns3__parameterListItem, sizeof(_ns3__parameterListItem), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns3__parameterListItem * SOAP_FMAC2 soap_instantiate__ns3__parameterListItem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__parameterListItem(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns3__parameterListItem *p;
	size_t k = sizeof(_ns3__parameterListItem);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns3__parameterListItem, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns3__parameterListItem);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns3__parameterListItem, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns3__parameterListItem location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns3__parameterListItem::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns3__parameterListItem(soap, tag ? tag : "ns3:parameterListItem", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__parameterListItem::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__parameterListItem(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__parameterListItem * SOAP_FMAC4 soap_get__ns3__parameterListItem(struct soap *soap, _ns3__parameterListItem *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__parameterListItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns3__subParameterListItem::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns3__subParameterListItem::subParameterName = NULL;
	this->ns3__subParameterListItem::subParameterValue = NULL;
}

void ns3__subParameterListItem::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->ns3__subParameterListItem::subParameterName);
	soap_serialize_PointerTostd__string(soap, &this->ns3__subParameterListItem::subParameterValue);
#endif
}

int ns3__subParameterListItem::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__subParameterListItem(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__subParameterListItem(struct soap *soap, const char *tag, int id, const ns3__subParameterListItem *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__subParameterListItem), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns3:subParameterName", -1, &a->ns3__subParameterListItem::subParameterName, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns3:subParameterValue", -1, &a->ns3__subParameterListItem::subParameterValue, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__subParameterListItem::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns3__subParameterListItem(soap, tag, this, type);
}

SOAP_FMAC3 ns3__subParameterListItem * SOAP_FMAC4 soap_in_ns3__subParameterListItem(struct soap *soap, const char *tag, ns3__subParameterListItem *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__subParameterListItem*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__subParameterListItem, sizeof(ns3__subParameterListItem), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns3__subParameterListItem)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns3__subParameterListItem *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_subParameterName1 = 1;
	size_t soap_flag_subParameterValue1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_subParameterName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns3:subParameterName", &a->ns3__subParameterListItem::subParameterName, "xsd:string"))
				{	soap_flag_subParameterName1--;
					continue;
				}
			}
			if (soap_flag_subParameterValue1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns3:subParameterValue", &a->ns3__subParameterListItem::subParameterValue, "xsd:string"))
				{	soap_flag_subParameterValue1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__subParameterListItem *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__subParameterListItem, SOAP_TYPE_ns3__subParameterListItem, sizeof(ns3__subParameterListItem), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns3__subParameterListItem * SOAP_FMAC2 soap_instantiate_ns3__subParameterListItem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__subParameterListItem(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns3__subParameterListItem *p;
	size_t k = sizeof(ns3__subParameterListItem);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns3__subParameterListItem, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns3__subParameterListItem);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns3__subParameterListItem, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns3__subParameterListItem location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns3__subParameterListItem::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns3__subParameterListItem(soap, tag ? tag : "ns3:subParameterListItem", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__subParameterListItem::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__subParameterListItem(soap, this, tag, type);
}

SOAP_FMAC3 ns3__subParameterListItem * SOAP_FMAC4 soap_get_ns3__subParameterListItem(struct soap *soap, ns3__subParameterListItem *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__subParameterListItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns3__responseParameterList::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTo_ns3__parameterListItem(soap, &this->ns3__responseParameterList::parameterListItem);
	this->ns3__responseParameterList::ResponseOperation = NULL;
	this->ns3__responseParameterList::ResponseType = NULL;
}

void ns3__responseParameterList::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTo_ns3__parameterListItem(soap, &this->ns3__responseParameterList::parameterListItem);
	soap_serialize_PointerTostd__string(soap, &this->ns3__responseParameterList::ResponseOperation);
	soap_serialize_PointerTostd__string(soap, &this->ns3__responseParameterList::ResponseType);
#endif
}

int ns3__responseParameterList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__responseParameterList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__responseParameterList(struct soap *soap, const char *tag, int id, const ns3__responseParameterList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__responseParameterList), type))
		return soap->error;
	soap_element_result(soap, "ns3:parameterListItem");
	if (soap_out_std__vectorTemplateOfPointerTo_ns3__parameterListItem(soap, "ns3:parameterListItem", -1, &a->ns3__responseParameterList::parameterListItem, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns3:ResponseOperation", -1, &a->ns3__responseParameterList::ResponseOperation, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns3:ResponseType", -1, &a->ns3__responseParameterList::ResponseType, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__responseParameterList::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns3__responseParameterList(soap, tag, this, type);
}

SOAP_FMAC3 ns3__responseParameterList * SOAP_FMAC4 soap_in_ns3__responseParameterList(struct soap *soap, const char *tag, ns3__responseParameterList *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__responseParameterList*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__responseParameterList, sizeof(ns3__responseParameterList), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns3__responseParameterList)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns3__responseParameterList *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ResponseOperation1 = 1;
	size_t soap_flag_ResponseType1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTo_ns3__parameterListItem(soap, "ns3:parameterListItem", &a->ns3__responseParameterList::parameterListItem, ""))
					continue;
			}
			if (soap_flag_ResponseOperation1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns3:ResponseOperation", &a->ns3__responseParameterList::ResponseOperation, "xsd:string"))
				{	soap_flag_ResponseOperation1--;
					continue;
				}
			}
			if (soap_flag_ResponseType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns3:ResponseType", &a->ns3__responseParameterList::ResponseType, "xsd:string"))
				{	soap_flag_ResponseType1--;
					continue;
				}
			}
			soap_check_result(soap, "ns3:parameterListItem");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__responseParameterList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__responseParameterList, SOAP_TYPE_ns3__responseParameterList, sizeof(ns3__responseParameterList), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns3__responseParameterList * SOAP_FMAC2 soap_instantiate_ns3__responseParameterList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__responseParameterList(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns3__responseParameterList *p;
	size_t k = sizeof(ns3__responseParameterList);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns3__responseParameterList, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns3__responseParameterList);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns3__responseParameterList, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns3__responseParameterList location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns3__responseParameterList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns3__responseParameterList(soap, tag ? tag : "ns3:responseParameterList", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__responseParameterList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__responseParameterList(soap, this, tag, type);
}

SOAP_FMAC3 ns3__responseParameterList * SOAP_FMAC4 soap_get_ns3__responseParameterList(struct soap *soap, ns3__responseParameterList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__responseParameterList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__parameterListItem::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__parameterListItem::parameterName = NULL;
	this->ns2__parameterListItem::comparisonOp = NULL;
	soap_default_std__vectorTemplateOfstd__string(soap, &this->ns2__parameterListItem::parameterValue);
	this->ns2__parameterListItem::logicalOp = NULL;
}

void ns2__parameterListItem::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->ns2__parameterListItem::parameterName);
	soap_serialize_PointerTostd__string(soap, &this->ns2__parameterListItem::comparisonOp);
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->ns2__parameterListItem::parameterValue);
	soap_serialize_PointerTostd__string(soap, &this->ns2__parameterListItem::logicalOp);
#endif
}

int ns2__parameterListItem::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__parameterListItem(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__parameterListItem(struct soap *soap, const char *tag, int id, const ns2__parameterListItem *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__parameterListItem), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns2:parameterName", -1, &a->ns2__parameterListItem::parameterName, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns2:comparisonOp", -1, &a->ns2__parameterListItem::comparisonOp, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "ns2:parameterValue", -1, &a->ns2__parameterListItem::parameterValue, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns2:logicalOp", -1, &a->ns2__parameterListItem::logicalOp, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__parameterListItem::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns2__parameterListItem(soap, tag, this, type);
}

SOAP_FMAC3 ns2__parameterListItem * SOAP_FMAC4 soap_in_ns2__parameterListItem(struct soap *soap, const char *tag, ns2__parameterListItem *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__parameterListItem*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__parameterListItem, sizeof(ns2__parameterListItem), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__parameterListItem)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__parameterListItem *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_parameterName1 = 1;
	size_t soap_flag_comparisonOp1 = 1;
	size_t soap_flag_logicalOp1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_parameterName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns2:parameterName", &a->ns2__parameterListItem::parameterName, "xsd:string"))
				{	soap_flag_parameterName1--;
					continue;
				}
			}
			if (soap_flag_comparisonOp1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns2:comparisonOp", &a->ns2__parameterListItem::comparisonOp, "xsd:string"))
				{	soap_flag_comparisonOp1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfstd__string(soap, "ns2:parameterValue", &a->ns2__parameterListItem::parameterValue, "xsd:string"))
					continue;
			}
			if (soap_flag_logicalOp1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns2:logicalOp", &a->ns2__parameterListItem::logicalOp, "xsd:string"))
				{	soap_flag_logicalOp1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__parameterListItem *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__parameterListItem, SOAP_TYPE_ns2__parameterListItem, sizeof(ns2__parameterListItem), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__parameterListItem * SOAP_FMAC2 soap_instantiate_ns2__parameterListItem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__parameterListItem(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__parameterListItem *p;
	size_t k = sizeof(ns2__parameterListItem);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns2__parameterListItem, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns2__parameterListItem);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns2__parameterListItem, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__parameterListItem location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns2__parameterListItem::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__parameterListItem(soap, tag ? tag : "ns2:parameterListItem", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__parameterListItem::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__parameterListItem(soap, this, tag, type);
}

SOAP_FMAC3 ns2__parameterListItem * SOAP_FMAC4 soap_get_ns2__parameterListItem(struct soap *soap, ns2__parameterListItem *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__parameterListItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__requestParameterList::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__requestParameterList::requestAPI = NULL;
	this->ns2__requestParameterList::requestOperation = NULL;
	soap_default_std__vectorTemplateOfPointerTons2__parameterListItem(soap, &this->ns2__requestParameterList::parameters);
}

void ns2__requestParameterList::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->ns2__requestParameterList::requestAPI);
	soap_serialize_PointerTostd__string(soap, &this->ns2__requestParameterList::requestOperation);
	soap_serialize_std__vectorTemplateOfPointerTons2__parameterListItem(soap, &this->ns2__requestParameterList::parameters);
#endif
}

int ns2__requestParameterList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__requestParameterList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__requestParameterList(struct soap *soap, const char *tag, int id, const ns2__requestParameterList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__requestParameterList), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns2:requestAPI", -1, &a->ns2__requestParameterList::requestAPI, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns2:requestOperation", -1, &a->ns2__requestParameterList::requestOperation, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons2__parameterListItem(soap, "ns2:parameters", -1, &a->ns2__requestParameterList::parameters, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__requestParameterList::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns2__requestParameterList(soap, tag, this, type);
}

SOAP_FMAC3 ns2__requestParameterList * SOAP_FMAC4 soap_in_ns2__requestParameterList(struct soap *soap, const char *tag, ns2__requestParameterList *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__requestParameterList*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__requestParameterList, sizeof(ns2__requestParameterList), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__requestParameterList)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__requestParameterList *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_requestAPI1 = 1;
	size_t soap_flag_requestOperation1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_requestAPI1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns2:requestAPI", &a->ns2__requestParameterList::requestAPI, "xsd:string"))
				{	soap_flag_requestAPI1--;
					continue;
				}
			}
			if (soap_flag_requestOperation1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns2:requestOperation", &a->ns2__requestParameterList::requestOperation, "xsd:string"))
				{	soap_flag_requestOperation1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons2__parameterListItem(soap, "ns2:parameters", &a->ns2__requestParameterList::parameters, "ns2:parameterListItem"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__requestParameterList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__requestParameterList, SOAP_TYPE_ns2__requestParameterList, sizeof(ns2__requestParameterList), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__requestParameterList * SOAP_FMAC2 soap_instantiate_ns2__requestParameterList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__requestParameterList(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__requestParameterList *p;
	size_t k = sizeof(ns2__requestParameterList);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns2__requestParameterList, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns2__requestParameterList);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns2__requestParameterList, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__requestParameterList location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns2__requestParameterList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__requestParameterList(soap, tag ? tag : "ns2:requestParameterList", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__requestParameterList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__requestParameterList(soap, this, tag, type);
}

SOAP_FMAC3 ns2__requestParameterList * SOAP_FMAC4 soap_get_ns2__requestParameterList(struct soap *soap, ns2__requestParameterList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__requestParameterList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__language(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__language(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__language), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__language(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__language, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 5, 0, -1, "([a-zA-Z]{2}|[iI]-[a-zA-Z]+|[xX]-[a-zA-Z]{1,8})(-[a-zA-Z]{1,8})*")))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__language, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_xsd__language, SOAP_TYPE_xsd__language, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__language(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_xsd__language(soap, tag ? tag : "xsd:language", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__language(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__language(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__integer(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__integer(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__integer), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__integer(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__integer, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 5, 0, -1, "[-+]?\\d+")))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__integer, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_xsd__integer, SOAP_TYPE_xsd__integer, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__integer(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_xsd__integer(soap, tag ? tag : "xsd:integer", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__integer(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__integer(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__decimal(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__decimal(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__decimal), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__decimal(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__decimal, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 5, 0, -1, "[-+]?(\\d+|\\d*\\.\\d*)")))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__decimal, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_xsd__decimal, SOAP_TYPE_xsd__decimal, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__decimal(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_xsd__decimal(soap, tag ? tag : "xsd:decimal", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__decimal(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__decimal(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__anyURI(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__anyURI(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__anyURI), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__anyURI(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__anyURI, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 4, 0, -1, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__anyURI, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_xsd__anyURI, SOAP_TYPE_xsd__anyURI, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__anyURI(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_xsd__anyURI(soap, tag ? tag : "xsd:anyURI", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__anyURI(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__anyURI(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__string(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__string(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_std__string), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_std__string(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_std__string, SOAP_TYPE_std__string, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_instantiate_std__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__string(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::string *p;
	size_t k = sizeof(std::string);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__string, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::string);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::string, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::string location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__string(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_std__string(soap, tag ? tag : "string", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_std__string(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_std__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getMessage(struct soap *soap, struct __ns1__getMessage *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getMessageTypeDef = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getMessage(struct soap *soap, const struct __ns1__getMessage *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons2__requestParameterList(soap, &a->ns1__getMessageTypeDef);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getMessage(struct soap *soap, const char *tag, int id, const struct __ns1__getMessage *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons2__requestParameterList(soap, "ns1:getMessageTypeDef", -1, &a->ns1__getMessageTypeDef, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getMessage * SOAP_FMAC4 soap_in___ns1__getMessage(struct soap *soap, const char *tag, struct __ns1__getMessage *a, const char *type)
{
	size_t soap_flag_ns1__getMessageTypeDef = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__getMessage*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getMessage, sizeof(struct __ns1__getMessage), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getMessage(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getMessageTypeDef && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons2__requestParameterList(soap, "ns1:getMessageTypeDef", &a->ns1__getMessageTypeDef, "ns2:requestParameterList"))
				{	soap_flag_ns1__getMessageTypeDef--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__getMessage * SOAP_FMAC2 soap_instantiate___ns1__getMessage(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getMessage(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__getMessage *p;
	size_t k = sizeof(struct __ns1__getMessage);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__getMessage, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__getMessage);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__getMessage, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__getMessage location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getMessage(struct soap *soap, const struct __ns1__getMessage *a, const char *tag, const char *type)
{
	if (soap_out___ns1__getMessage(soap, tag ? tag : "-ns1:getMessage", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getMessage * SOAP_FMAC4 soap_get___ns1__getMessage(struct soap *soap, struct __ns1__getMessage *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getMessage(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__postCAP(struct soap *soap, struct __ns1__postCAP *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__postCAPRequestTypeDef = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__postCAP(struct soap *soap, const struct __ns1__postCAP *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__postCAPRequestTypeDef(soap, &a->ns1__postCAPRequestTypeDef);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__postCAP(struct soap *soap, const char *tag, int id, const struct __ns1__postCAP *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__postCAPRequestTypeDef(soap, "ns1:postCAPRequestTypeDef", -1, &a->ns1__postCAPRequestTypeDef, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__postCAP * SOAP_FMAC4 soap_in___ns1__postCAP(struct soap *soap, const char *tag, struct __ns1__postCAP *a, const char *type)
{
	size_t soap_flag_ns1__postCAPRequestTypeDef = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__postCAP*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__postCAP, sizeof(struct __ns1__postCAP), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__postCAP(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__postCAPRequestTypeDef && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__postCAPRequestTypeDef(soap, "ns1:postCAPRequestTypeDef", &a->ns1__postCAPRequestTypeDef, ""))
				{	soap_flag_ns1__postCAPRequestTypeDef--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__postCAP * SOAP_FMAC2 soap_instantiate___ns1__postCAP(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__postCAP(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__postCAP *p;
	size_t k = sizeof(struct __ns1__postCAP);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__postCAP, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__postCAP);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__postCAP, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__postCAP location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__postCAP(struct soap *soap, const struct __ns1__postCAP *a, const char *tag, const char *type)
{
	if (soap_out___ns1__postCAP(soap, tag ? tag : "-ns1:postCAP", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__postCAP * SOAP_FMAC4 soap_get___ns1__postCAP(struct soap *soap, struct __ns1__postCAP *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__postCAP(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getRequest(struct soap *soap, struct __ns1__getRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getRequestTypeDef = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getRequest(struct soap *soap, const struct __ns1__getRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons2__requestParameterList(soap, &a->ns1__getRequestTypeDef);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getRequest(struct soap *soap, const char *tag, int id, const struct __ns1__getRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons2__requestParameterList(soap, "ns1:getRequestTypeDef", -1, &a->ns1__getRequestTypeDef, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getRequest * SOAP_FMAC4 soap_in___ns1__getRequest(struct soap *soap, const char *tag, struct __ns1__getRequest *a, const char *type)
{
	size_t soap_flag_ns1__getRequestTypeDef = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__getRequest*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getRequest, sizeof(struct __ns1__getRequest), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getRequest(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getRequestTypeDef && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons2__requestParameterList(soap, "ns1:getRequestTypeDef", &a->ns1__getRequestTypeDef, "ns2:requestParameterList"))
				{	soap_flag_ns1__getRequestTypeDef--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__getRequest * SOAP_FMAC2 soap_instantiate___ns1__getRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getRequest(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__getRequest *p;
	size_t k = sizeof(struct __ns1__getRequest);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__getRequest, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__getRequest);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__getRequest, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__getRequest location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getRequest(struct soap *soap, const struct __ns1__getRequest *a, const char *tag, const char *type)
{
	if (soap_out___ns1__getRequest(soap, tag ? tag : "-ns1:getRequest", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getRequest * SOAP_FMAC4 soap_get___ns1__getRequest(struct soap *soap, struct __ns1__getRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__CAPServiceException = NULL;
	a->__type = 0;
	a->fault = NULL;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__CAPServiceException(soap, &a->ns1__CAPServiceException);
	soap_markelement(soap, a->fault, a->__type);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
		return soap->error;
	if (soap_out_PointerTo_ns1__CAPServiceException(soap, "ns1:CAPServiceException", -1, &a->ns1__CAPServiceException, ""))
		return soap->error;
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	if (soap_outliteral(soap, "-any", (char*const*)&a->__any, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag_ns1__CAPServiceException = 1;
	size_t soap_flag_fault = 1;
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct SOAP_ENV__Detail*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__CAPServiceException && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__CAPServiceException(soap, "ns1:CAPServiceException", &a->ns1__CAPServiceException, ""))
				{	soap_flag_ns1__CAPServiceException--;
					continue;
				}
			}
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
			{	if ((a->fault = soap_getelement(soap, "fault", &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-any", (char**)&a->__any))
				{	soap_flag___any--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Detail(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Detail *p;
	size_t k = sizeof(struct SOAP_ENV__Detail);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_SOAP_ENV__Detail, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct SOAP_ENV__Detail);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct SOAP_ENV__Detail, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Detail location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Detail(soap, tag ? tag : "SOAP-ENV:Detail", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__CAPHeaderTypeDef = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__CAPHeaderTypeDef(soap, &a->ns1__CAPHeaderTypeDef);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;
	soap->mustUnderstand = 1;
	if (soap_out_PointerTo_ns1__CAPHeaderTypeDef(soap, "ns1:CAPHeaderTypeDef", -1, &a->ns1__CAPHeaderTypeDef, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	size_t soap_flag_ns1__CAPHeaderTypeDef = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct SOAP_ENV__Header*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__CAPHeaderTypeDef && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__CAPHeaderTypeDef(soap, "ns1:CAPHeaderTypeDef", &a->ns1__CAPHeaderTypeDef, ""))
				{	soap_flag_ns1__CAPHeaderTypeDef--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Header(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Header *p;
	size_t k = sizeof(struct SOAP_ENV__Header);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_SOAP_ENV__Header, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct SOAP_ENV__Header);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct SOAP_ENV__Header, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Header location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Header(soap, tag ? tag : "SOAP-ENV:Header", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo__ns1__getMessage(struct soap *soap, struct __ns1__getMessage *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE___ns1__getMessage))
		soap_serialize___ns1__getMessage(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo__ns1__getMessage(struct soap *soap, const char *tag, int id, struct __ns1__getMessage *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE___ns1__getMessage, NULL);
	if (id < 0)
		return soap->error;
	return soap_out___ns1__getMessage(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct __ns1__getMessage ** SOAP_FMAC4 soap_in_PointerTo__ns1__getMessage(struct soap *soap, const char *tag, struct __ns1__getMessage **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct __ns1__getMessage **)soap_malloc(soap, sizeof(struct __ns1__getMessage *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in___ns1__getMessage(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct __ns1__getMessage **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE___ns1__getMessage, sizeof(struct __ns1__getMessage), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo__ns1__getMessage(struct soap *soap, struct __ns1__getMessage *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo__ns1__getMessage(soap, tag ? tag : "-ns1:getMessage", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct __ns1__getMessage ** SOAP_FMAC4 soap_get_PointerTo__ns1__getMessage(struct soap *soap, struct __ns1__getMessage **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo__ns1__getMessage(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo__ns1__postCAP(struct soap *soap, struct __ns1__postCAP *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE___ns1__postCAP))
		soap_serialize___ns1__postCAP(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo__ns1__postCAP(struct soap *soap, const char *tag, int id, struct __ns1__postCAP *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE___ns1__postCAP, NULL);
	if (id < 0)
		return soap->error;
	return soap_out___ns1__postCAP(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct __ns1__postCAP ** SOAP_FMAC4 soap_in_PointerTo__ns1__postCAP(struct soap *soap, const char *tag, struct __ns1__postCAP **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct __ns1__postCAP **)soap_malloc(soap, sizeof(struct __ns1__postCAP *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in___ns1__postCAP(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct __ns1__postCAP **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE___ns1__postCAP, sizeof(struct __ns1__postCAP), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo__ns1__postCAP(struct soap *soap, struct __ns1__postCAP *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo__ns1__postCAP(soap, tag ? tag : "-ns1:postCAP", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct __ns1__postCAP ** SOAP_FMAC4 soap_get_PointerTo__ns1__postCAP(struct soap *soap, struct __ns1__postCAP **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo__ns1__postCAP(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo__ns1__getRequest(struct soap *soap, struct __ns1__getRequest *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE___ns1__getRequest))
		soap_serialize___ns1__getRequest(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo__ns1__getRequest(struct soap *soap, const char *tag, int id, struct __ns1__getRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE___ns1__getRequest, NULL);
	if (id < 0)
		return soap->error;
	return soap_out___ns1__getRequest(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct __ns1__getRequest ** SOAP_FMAC4 soap_in_PointerTo__ns1__getRequest(struct soap *soap, const char *tag, struct __ns1__getRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct __ns1__getRequest **)soap_malloc(soap, sizeof(struct __ns1__getRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in___ns1__getRequest(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct __ns1__getRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE___ns1__getRequest, sizeof(struct __ns1__getRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo__ns1__getRequest(struct soap *soap, struct __ns1__getRequest *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo__ns1__getRequest(soap, tag ? tag : "-ns1:getRequest", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct __ns1__getRequest ** SOAP_FMAC4 soap_get_PointerTo__ns1__getRequest(struct soap *soap, struct __ns1__getRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo__ns1__getRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag ? tag : "SOAP-ENV:Detail", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Header))
		soap_serialize_SOAP_ENV__Header(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Header(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Header *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Header, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Header(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Header ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Header **)soap_malloc(soap, sizeof(struct SOAP_ENV__Header *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Header(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Header(soap, tag ? tag : "SOAP-ENV:Header", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Header ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToint(struct soap *soap, int *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToint(struct soap *soap, const char *tag, int id, int *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_int, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_int(soap, tag, id, *a, type);
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_in_PointerToint(struct soap *soap, const char *tag, int **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (int **)soap_malloc(soap, sizeof(int *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_int(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (int **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_int, sizeof(int), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToint(struct soap *soap, int *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToint(soap, tag ? tag : "int", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_get_PointerToint(struct soap *soap, int **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToint(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__decimal(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__decimal))
		soap_serialize_xsd__decimal(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__decimal(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__decimal, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__decimal(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerToxsd__decimal(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__decimal(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__decimal, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__decimal(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToxsd__decimal(soap, tag ? tag : "xsd:decimal", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerToxsd__decimal(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__decimal(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns22__alert_info_area_geocode(struct soap *soap, _ns22__alert_info_area_geocode *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns22__alert_info_area_geocode))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns22__alert_info_area_geocode(struct soap *soap, const char *tag, int id, _ns22__alert_info_area_geocode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns22__alert_info_area_geocode, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns22__alert_info_area_geocode ? type : NULL);
}

SOAP_FMAC3 _ns22__alert_info_area_geocode ** SOAP_FMAC4 soap_in_PointerTo_ns22__alert_info_area_geocode(struct soap *soap, const char *tag, _ns22__alert_info_area_geocode **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns22__alert_info_area_geocode **)soap_malloc(soap, sizeof(_ns22__alert_info_area_geocode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns22__alert_info_area_geocode *)soap_instantiate__ns22__alert_info_area_geocode(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns22__alert_info_area_geocode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns22__alert_info_area_geocode, sizeof(_ns22__alert_info_area_geocode), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns22__alert_info_area_geocode(struct soap *soap, _ns22__alert_info_area_geocode *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns22__alert_info_area_geocode(soap, tag ? tag : "ns22:alert-info-area-geocode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns22__alert_info_area_geocode ** SOAP_FMAC4 soap_get_PointerTo_ns22__alert_info_area_geocode(struct soap *soap, _ns22__alert_info_area_geocode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns22__alert_info_area_geocode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns22__alert_info_area(struct soap *soap, _ns22__alert_info_area *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns22__alert_info_area))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns22__alert_info_area(struct soap *soap, const char *tag, int id, _ns22__alert_info_area *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns22__alert_info_area, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns22__alert_info_area ? type : NULL);
}

SOAP_FMAC3 _ns22__alert_info_area ** SOAP_FMAC4 soap_in_PointerTo_ns22__alert_info_area(struct soap *soap, const char *tag, _ns22__alert_info_area **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns22__alert_info_area **)soap_malloc(soap, sizeof(_ns22__alert_info_area *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns22__alert_info_area *)soap_instantiate__ns22__alert_info_area(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns22__alert_info_area **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns22__alert_info_area, sizeof(_ns22__alert_info_area), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns22__alert_info_area(struct soap *soap, _ns22__alert_info_area *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns22__alert_info_area(soap, tag ? tag : "ns22:alert-info-area", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns22__alert_info_area ** SOAP_FMAC4 soap_get_PointerTo_ns22__alert_info_area(struct soap *soap, _ns22__alert_info_area **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns22__alert_info_area(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__integer(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__integer))
		soap_serialize_xsd__integer(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__integer(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__integer, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__integer(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerToxsd__integer(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__integer(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__integer, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__integer(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToxsd__integer(soap, tag ? tag : "xsd:integer", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerToxsd__integer(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__integer(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns22__alert_info_resource(struct soap *soap, _ns22__alert_info_resource *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns22__alert_info_resource))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns22__alert_info_resource(struct soap *soap, const char *tag, int id, _ns22__alert_info_resource *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns22__alert_info_resource, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns22__alert_info_resource ? type : NULL);
}

SOAP_FMAC3 _ns22__alert_info_resource ** SOAP_FMAC4 soap_in_PointerTo_ns22__alert_info_resource(struct soap *soap, const char *tag, _ns22__alert_info_resource **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns22__alert_info_resource **)soap_malloc(soap, sizeof(_ns22__alert_info_resource *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns22__alert_info_resource *)soap_instantiate__ns22__alert_info_resource(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns22__alert_info_resource **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns22__alert_info_resource, sizeof(_ns22__alert_info_resource), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns22__alert_info_resource(struct soap *soap, _ns22__alert_info_resource *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns22__alert_info_resource(soap, tag ? tag : "ns22:alert-info-resource", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns22__alert_info_resource ** SOAP_FMAC4 soap_get_PointerTo_ns22__alert_info_resource(struct soap *soap, _ns22__alert_info_resource **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns22__alert_info_resource(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns22__alert_info_parameter(struct soap *soap, _ns22__alert_info_parameter *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns22__alert_info_parameter))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns22__alert_info_parameter(struct soap *soap, const char *tag, int id, _ns22__alert_info_parameter *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns22__alert_info_parameter, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns22__alert_info_parameter ? type : NULL);
}

SOAP_FMAC3 _ns22__alert_info_parameter ** SOAP_FMAC4 soap_in_PointerTo_ns22__alert_info_parameter(struct soap *soap, const char *tag, _ns22__alert_info_parameter **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns22__alert_info_parameter **)soap_malloc(soap, sizeof(_ns22__alert_info_parameter *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns22__alert_info_parameter *)soap_instantiate__ns22__alert_info_parameter(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns22__alert_info_parameter **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns22__alert_info_parameter, sizeof(_ns22__alert_info_parameter), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns22__alert_info_parameter(struct soap *soap, _ns22__alert_info_parameter *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns22__alert_info_parameter(soap, tag ? tag : "ns22:alert-info-parameter", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns22__alert_info_parameter ** SOAP_FMAC4 soap_get_PointerTo_ns22__alert_info_parameter(struct soap *soap, _ns22__alert_info_parameter **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns22__alert_info_parameter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__anyURI(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__anyURI))
		soap_serialize_xsd__anyURI(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__anyURI(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__anyURI, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__anyURI(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerToxsd__anyURI(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__anyURI(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__anyURI, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__anyURI(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToxsd__anyURI(soap, tag ? tag : "xsd:anyURI", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerToxsd__anyURI(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__anyURI(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTodateTime(struct soap *soap, time_t *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_dateTime);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTodateTime(struct soap *soap, const char *tag, int id, time_t *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_dateTime, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_dateTime(soap, tag, id, *a, type);
}

SOAP_FMAC3 time_t ** SOAP_FMAC4 soap_in_PointerTodateTime(struct soap *soap, const char *tag, time_t **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (time_t **)soap_malloc(soap, sizeof(time_t *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_dateTime(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (time_t **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_dateTime, sizeof(time_t), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTodateTime(struct soap *soap, time_t *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTodateTime(soap, tag ? tag : "dateTime", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 time_t ** SOAP_FMAC4 soap_get_PointerTodateTime(struct soap *soap, time_t **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTodateTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns22__alert_info_eventCode(struct soap *soap, _ns22__alert_info_eventCode *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns22__alert_info_eventCode))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns22__alert_info_eventCode(struct soap *soap, const char *tag, int id, _ns22__alert_info_eventCode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns22__alert_info_eventCode, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns22__alert_info_eventCode ? type : NULL);
}

SOAP_FMAC3 _ns22__alert_info_eventCode ** SOAP_FMAC4 soap_in_PointerTo_ns22__alert_info_eventCode(struct soap *soap, const char *tag, _ns22__alert_info_eventCode **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns22__alert_info_eventCode **)soap_malloc(soap, sizeof(_ns22__alert_info_eventCode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns22__alert_info_eventCode *)soap_instantiate__ns22__alert_info_eventCode(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns22__alert_info_eventCode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns22__alert_info_eventCode, sizeof(_ns22__alert_info_eventCode), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns22__alert_info_eventCode(struct soap *soap, _ns22__alert_info_eventCode *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns22__alert_info_eventCode(soap, tag ? tag : "ns22:alert-info-eventCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns22__alert_info_eventCode ** SOAP_FMAC4 soap_get_PointerTo_ns22__alert_info_eventCode(struct soap *soap, _ns22__alert_info_eventCode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns22__alert_info_eventCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns22__alert_info_certainty(struct soap *soap, enum _ns22__alert_info_certainty *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE__ns22__alert_info_certainty);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns22__alert_info_certainty(struct soap *soap, const char *tag, int id, enum _ns22__alert_info_certainty *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns22__alert_info_certainty, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__ns22__alert_info_certainty(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum _ns22__alert_info_certainty ** SOAP_FMAC4 soap_in_PointerTo_ns22__alert_info_certainty(struct soap *soap, const char *tag, enum _ns22__alert_info_certainty **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum _ns22__alert_info_certainty **)soap_malloc(soap, sizeof(enum _ns22__alert_info_certainty *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns22__alert_info_certainty(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum _ns22__alert_info_certainty **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns22__alert_info_certainty, sizeof(enum _ns22__alert_info_certainty), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns22__alert_info_certainty(struct soap *soap, enum _ns22__alert_info_certainty *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns22__alert_info_certainty(soap, tag ? tag : "ns22:alert-info-certainty", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum _ns22__alert_info_certainty ** SOAP_FMAC4 soap_get_PointerTo_ns22__alert_info_certainty(struct soap *soap, enum _ns22__alert_info_certainty **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns22__alert_info_certainty(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns22__alert_info_severity(struct soap *soap, enum _ns22__alert_info_severity *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE__ns22__alert_info_severity);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns22__alert_info_severity(struct soap *soap, const char *tag, int id, enum _ns22__alert_info_severity *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns22__alert_info_severity, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__ns22__alert_info_severity(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum _ns22__alert_info_severity ** SOAP_FMAC4 soap_in_PointerTo_ns22__alert_info_severity(struct soap *soap, const char *tag, enum _ns22__alert_info_severity **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum _ns22__alert_info_severity **)soap_malloc(soap, sizeof(enum _ns22__alert_info_severity *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns22__alert_info_severity(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum _ns22__alert_info_severity **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns22__alert_info_severity, sizeof(enum _ns22__alert_info_severity), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns22__alert_info_severity(struct soap *soap, enum _ns22__alert_info_severity *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns22__alert_info_severity(soap, tag ? tag : "ns22:alert-info-severity", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum _ns22__alert_info_severity ** SOAP_FMAC4 soap_get_PointerTo_ns22__alert_info_severity(struct soap *soap, enum _ns22__alert_info_severity **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns22__alert_info_severity(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns22__alert_info_urgency(struct soap *soap, enum _ns22__alert_info_urgency *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE__ns22__alert_info_urgency);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns22__alert_info_urgency(struct soap *soap, const char *tag, int id, enum _ns22__alert_info_urgency *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns22__alert_info_urgency, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__ns22__alert_info_urgency(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum _ns22__alert_info_urgency ** SOAP_FMAC4 soap_in_PointerTo_ns22__alert_info_urgency(struct soap *soap, const char *tag, enum _ns22__alert_info_urgency **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum _ns22__alert_info_urgency **)soap_malloc(soap, sizeof(enum _ns22__alert_info_urgency *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns22__alert_info_urgency(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum _ns22__alert_info_urgency **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns22__alert_info_urgency, sizeof(enum _ns22__alert_info_urgency), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns22__alert_info_urgency(struct soap *soap, enum _ns22__alert_info_urgency *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns22__alert_info_urgency(soap, tag ? tag : "ns22:alert-info-urgency", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum _ns22__alert_info_urgency ** SOAP_FMAC4 soap_get_PointerTo_ns22__alert_info_urgency(struct soap *soap, enum _ns22__alert_info_urgency **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns22__alert_info_urgency(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns22__alert_info_responseType(struct soap *soap, enum _ns22__alert_info_responseType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE__ns22__alert_info_responseType);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns22__alert_info_responseType(struct soap *soap, const char *tag, int id, enum _ns22__alert_info_responseType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns22__alert_info_responseType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__ns22__alert_info_responseType(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum _ns22__alert_info_responseType ** SOAP_FMAC4 soap_in_PointerTo_ns22__alert_info_responseType(struct soap *soap, const char *tag, enum _ns22__alert_info_responseType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum _ns22__alert_info_responseType **)soap_malloc(soap, sizeof(enum _ns22__alert_info_responseType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns22__alert_info_responseType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum _ns22__alert_info_responseType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns22__alert_info_responseType, sizeof(enum _ns22__alert_info_responseType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns22__alert_info_responseType(struct soap *soap, enum _ns22__alert_info_responseType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns22__alert_info_responseType(soap, tag ? tag : "ns22:alert-info-responseType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum _ns22__alert_info_responseType ** SOAP_FMAC4 soap_get_PointerTo_ns22__alert_info_responseType(struct soap *soap, enum _ns22__alert_info_responseType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns22__alert_info_responseType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns22__alert_info_category(struct soap *soap, enum _ns22__alert_info_category *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE__ns22__alert_info_category);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns22__alert_info_category(struct soap *soap, const char *tag, int id, enum _ns22__alert_info_category *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns22__alert_info_category, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__ns22__alert_info_category(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum _ns22__alert_info_category ** SOAP_FMAC4 soap_in_PointerTo_ns22__alert_info_category(struct soap *soap, const char *tag, enum _ns22__alert_info_category **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum _ns22__alert_info_category **)soap_malloc(soap, sizeof(enum _ns22__alert_info_category *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns22__alert_info_category(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum _ns22__alert_info_category **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns22__alert_info_category, sizeof(enum _ns22__alert_info_category), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns22__alert_info_category(struct soap *soap, enum _ns22__alert_info_category *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns22__alert_info_category(soap, tag ? tag : "ns22:alert-info-category", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum _ns22__alert_info_category ** SOAP_FMAC4 soap_get_PointerTo_ns22__alert_info_category(struct soap *soap, enum _ns22__alert_info_category **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns22__alert_info_category(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__language(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__language))
		soap_serialize_xsd__language(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__language(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__language, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__language(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerToxsd__language(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__language(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__language, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__language(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToxsd__language(soap, tag ? tag : "xsd:language", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerToxsd__language(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__language(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns22__alert_info(struct soap *soap, _ns22__alert_info *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns22__alert_info))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns22__alert_info(struct soap *soap, const char *tag, int id, _ns22__alert_info *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns22__alert_info, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns22__alert_info ? type : NULL);
}

SOAP_FMAC3 _ns22__alert_info ** SOAP_FMAC4 soap_in_PointerTo_ns22__alert_info(struct soap *soap, const char *tag, _ns22__alert_info **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns22__alert_info **)soap_malloc(soap, sizeof(_ns22__alert_info *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns22__alert_info *)soap_instantiate__ns22__alert_info(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns22__alert_info **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns22__alert_info, sizeof(_ns22__alert_info), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns22__alert_info(struct soap *soap, _ns22__alert_info *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns22__alert_info(soap, tag ? tag : "ns22:alert-info", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns22__alert_info ** SOAP_FMAC4 soap_get_PointerTo_ns22__alert_info(struct soap *soap, _ns22__alert_info **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns22__alert_info(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns22__alert_scope(struct soap *soap, enum _ns22__alert_scope *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE__ns22__alert_scope);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns22__alert_scope(struct soap *soap, const char *tag, int id, enum _ns22__alert_scope *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns22__alert_scope, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__ns22__alert_scope(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum _ns22__alert_scope ** SOAP_FMAC4 soap_in_PointerTo_ns22__alert_scope(struct soap *soap, const char *tag, enum _ns22__alert_scope **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum _ns22__alert_scope **)soap_malloc(soap, sizeof(enum _ns22__alert_scope *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns22__alert_scope(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum _ns22__alert_scope **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns22__alert_scope, sizeof(enum _ns22__alert_scope), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns22__alert_scope(struct soap *soap, enum _ns22__alert_scope *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns22__alert_scope(soap, tag ? tag : "ns22:alert-scope", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum _ns22__alert_scope ** SOAP_FMAC4 soap_get_PointerTo_ns22__alert_scope(struct soap *soap, enum _ns22__alert_scope **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns22__alert_scope(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns22__alert_msgType(struct soap *soap, enum _ns22__alert_msgType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE__ns22__alert_msgType);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns22__alert_msgType(struct soap *soap, const char *tag, int id, enum _ns22__alert_msgType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns22__alert_msgType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__ns22__alert_msgType(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum _ns22__alert_msgType ** SOAP_FMAC4 soap_in_PointerTo_ns22__alert_msgType(struct soap *soap, const char *tag, enum _ns22__alert_msgType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum _ns22__alert_msgType **)soap_malloc(soap, sizeof(enum _ns22__alert_msgType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns22__alert_msgType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum _ns22__alert_msgType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns22__alert_msgType, sizeof(enum _ns22__alert_msgType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns22__alert_msgType(struct soap *soap, enum _ns22__alert_msgType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns22__alert_msgType(soap, tag ? tag : "ns22:alert-msgType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum _ns22__alert_msgType ** SOAP_FMAC4 soap_get_PointerTo_ns22__alert_msgType(struct soap *soap, enum _ns22__alert_msgType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns22__alert_msgType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns22__alert_status(struct soap *soap, enum _ns22__alert_status *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE__ns22__alert_status);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns22__alert_status(struct soap *soap, const char *tag, int id, enum _ns22__alert_status *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns22__alert_status, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__ns22__alert_status(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum _ns22__alert_status ** SOAP_FMAC4 soap_in_PointerTo_ns22__alert_status(struct soap *soap, const char *tag, enum _ns22__alert_status **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum _ns22__alert_status **)soap_malloc(soap, sizeof(enum _ns22__alert_status *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns22__alert_status(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum _ns22__alert_status **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns22__alert_status, sizeof(enum _ns22__alert_status), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns22__alert_status(struct soap *soap, enum _ns22__alert_status *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns22__alert_status(soap, tag ? tag : "ns22:alert-status", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum _ns22__alert_status ** SOAP_FMAC4 soap_get_PointerTo_ns22__alert_status(struct soap *soap, enum _ns22__alert_status **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns22__alert_status(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__CAPHeaderTypeDef(struct soap *soap, _ns1__CAPHeaderTypeDef *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__CAPHeaderTypeDef))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__CAPHeaderTypeDef(struct soap *soap, const char *tag, int id, _ns1__CAPHeaderTypeDef *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__CAPHeaderTypeDef, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__CAPHeaderTypeDef ? type : NULL);
}

SOAP_FMAC3 _ns1__CAPHeaderTypeDef ** SOAP_FMAC4 soap_in_PointerTo_ns1__CAPHeaderTypeDef(struct soap *soap, const char *tag, _ns1__CAPHeaderTypeDef **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__CAPHeaderTypeDef **)soap_malloc(soap, sizeof(_ns1__CAPHeaderTypeDef *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__CAPHeaderTypeDef *)soap_instantiate__ns1__CAPHeaderTypeDef(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__CAPHeaderTypeDef **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__CAPHeaderTypeDef, sizeof(_ns1__CAPHeaderTypeDef), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__CAPHeaderTypeDef(struct soap *soap, _ns1__CAPHeaderTypeDef *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__CAPHeaderTypeDef(soap, tag ? tag : "ns1:CAPHeaderTypeDef", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__CAPHeaderTypeDef ** SOAP_FMAC4 soap_get_PointerTo_ns1__CAPHeaderTypeDef(struct soap *soap, _ns1__CAPHeaderTypeDef **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__CAPHeaderTypeDef(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__messageResponseTypeDef(struct soap *soap, _ns1__messageResponseTypeDef *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__messageResponseTypeDef))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__messageResponseTypeDef(struct soap *soap, const char *tag, int id, _ns1__messageResponseTypeDef *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__messageResponseTypeDef, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__messageResponseTypeDef ? type : NULL);
}

SOAP_FMAC3 _ns1__messageResponseTypeDef ** SOAP_FMAC4 soap_in_PointerTo_ns1__messageResponseTypeDef(struct soap *soap, const char *tag, _ns1__messageResponseTypeDef **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__messageResponseTypeDef **)soap_malloc(soap, sizeof(_ns1__messageResponseTypeDef *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__messageResponseTypeDef *)soap_instantiate__ns1__messageResponseTypeDef(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__messageResponseTypeDef **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__messageResponseTypeDef, sizeof(_ns1__messageResponseTypeDef), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__messageResponseTypeDef(struct soap *soap, _ns1__messageResponseTypeDef *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__messageResponseTypeDef(soap, tag ? tag : "ns1:messageResponseTypeDef", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__messageResponseTypeDef ** SOAP_FMAC4 soap_get_PointerTo_ns1__messageResponseTypeDef(struct soap *soap, _ns1__messageResponseTypeDef **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__messageResponseTypeDef(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__postCAPResponseTypeDef(struct soap *soap, _ns1__postCAPResponseTypeDef *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__postCAPResponseTypeDef))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__postCAPResponseTypeDef(struct soap *soap, const char *tag, int id, _ns1__postCAPResponseTypeDef *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__postCAPResponseTypeDef, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__postCAPResponseTypeDef ? type : NULL);
}

SOAP_FMAC3 _ns1__postCAPResponseTypeDef ** SOAP_FMAC4 soap_in_PointerTo_ns1__postCAPResponseTypeDef(struct soap *soap, const char *tag, _ns1__postCAPResponseTypeDef **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__postCAPResponseTypeDef **)soap_malloc(soap, sizeof(_ns1__postCAPResponseTypeDef *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__postCAPResponseTypeDef *)soap_instantiate__ns1__postCAPResponseTypeDef(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__postCAPResponseTypeDef **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__postCAPResponseTypeDef, sizeof(_ns1__postCAPResponseTypeDef), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__postCAPResponseTypeDef(struct soap *soap, _ns1__postCAPResponseTypeDef *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__postCAPResponseTypeDef(soap, tag ? tag : "ns1:postCAPResponseTypeDef", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__postCAPResponseTypeDef ** SOAP_FMAC4 soap_get_PointerTo_ns1__postCAPResponseTypeDef(struct soap *soap, _ns1__postCAPResponseTypeDef **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__postCAPResponseTypeDef(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__CAPServiceException(struct soap *soap, _ns1__CAPServiceException *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__CAPServiceException))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__CAPServiceException(struct soap *soap, const char *tag, int id, _ns1__CAPServiceException *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__CAPServiceException, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__CAPServiceException ? type : NULL);
}

SOAP_FMAC3 _ns1__CAPServiceException ** SOAP_FMAC4 soap_in_PointerTo_ns1__CAPServiceException(struct soap *soap, const char *tag, _ns1__CAPServiceException **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__CAPServiceException **)soap_malloc(soap, sizeof(_ns1__CAPServiceException *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__CAPServiceException *)soap_instantiate__ns1__CAPServiceException(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__CAPServiceException **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__CAPServiceException, sizeof(_ns1__CAPServiceException), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__CAPServiceException(struct soap *soap, _ns1__CAPServiceException *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__CAPServiceException(soap, tag ? tag : "ns1:CAPServiceException", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__CAPServiceException ** SOAP_FMAC4 soap_get_PointerTo_ns1__CAPServiceException(struct soap *soap, _ns1__CAPServiceException **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__CAPServiceException(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__postCAPRequestTypeDef(struct soap *soap, _ns1__postCAPRequestTypeDef *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__postCAPRequestTypeDef))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__postCAPRequestTypeDef(struct soap *soap, const char *tag, int id, _ns1__postCAPRequestTypeDef *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__postCAPRequestTypeDef, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__postCAPRequestTypeDef ? type : NULL);
}

SOAP_FMAC3 _ns1__postCAPRequestTypeDef ** SOAP_FMAC4 soap_in_PointerTo_ns1__postCAPRequestTypeDef(struct soap *soap, const char *tag, _ns1__postCAPRequestTypeDef **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__postCAPRequestTypeDef **)soap_malloc(soap, sizeof(_ns1__postCAPRequestTypeDef *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__postCAPRequestTypeDef *)soap_instantiate__ns1__postCAPRequestTypeDef(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__postCAPRequestTypeDef **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__postCAPRequestTypeDef, sizeof(_ns1__postCAPRequestTypeDef), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__postCAPRequestTypeDef(struct soap *soap, _ns1__postCAPRequestTypeDef *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__postCAPRequestTypeDef(soap, tag ? tag : "ns1:postCAPRequestTypeDef", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__postCAPRequestTypeDef ** SOAP_FMAC4 soap_get_PointerTo_ns1__postCAPRequestTypeDef(struct soap *soap, _ns1__postCAPRequestTypeDef **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__postCAPRequestTypeDef(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns22__alert(struct soap *soap, _ns22__alert *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns22__alert))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns22__alert(struct soap *soap, const char *tag, int id, _ns22__alert *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns22__alert, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns22__alert ? type : NULL);
}

SOAP_FMAC3 _ns22__alert ** SOAP_FMAC4 soap_in_PointerTo_ns22__alert(struct soap *soap, const char *tag, _ns22__alert **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns22__alert **)soap_malloc(soap, sizeof(_ns22__alert *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns22__alert *)soap_instantiate__ns22__alert(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns22__alert **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns22__alert, sizeof(_ns22__alert), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns22__alert(struct soap *soap, _ns22__alert *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns22__alert(soap, tag ? tag : "ns22:alert", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns22__alert ** SOAP_FMAC4 soap_get_PointerTo_ns22__alert(struct soap *soap, _ns22__alert **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns22__alert(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__parameterListItem(struct soap *soap, _ns3__parameterListItem *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns3__parameterListItem))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__parameterListItem(struct soap *soap, const char *tag, int id, _ns3__parameterListItem *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns3__parameterListItem, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns3__parameterListItem ? type : NULL);
}

SOAP_FMAC3 _ns3__parameterListItem ** SOAP_FMAC4 soap_in_PointerTo_ns3__parameterListItem(struct soap *soap, const char *tag, _ns3__parameterListItem **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__parameterListItem **)soap_malloc(soap, sizeof(_ns3__parameterListItem *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__parameterListItem *)soap_instantiate__ns3__parameterListItem(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns3__parameterListItem **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns3__parameterListItem, sizeof(_ns3__parameterListItem), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__parameterListItem(struct soap *soap, _ns3__parameterListItem *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns3__parameterListItem(soap, tag ? tag : "ns3:parameterListItem", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns3__parameterListItem ** SOAP_FMAC4 soap_get_PointerTo_ns3__parameterListItem(struct soap *soap, _ns3__parameterListItem **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__parameterListItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__subParameterListItem(struct soap *soap, ns3__subParameterListItem *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns3__subParameterListItem))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__subParameterListItem(struct soap *soap, const char *tag, int id, ns3__subParameterListItem *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns3__subParameterListItem, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns3__subParameterListItem ? type : NULL);
}

SOAP_FMAC3 ns3__subParameterListItem ** SOAP_FMAC4 soap_in_PointerTons3__subParameterListItem(struct soap *soap, const char *tag, ns3__subParameterListItem **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__subParameterListItem **)soap_malloc(soap, sizeof(ns3__subParameterListItem *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__subParameterListItem *)soap_instantiate_ns3__subParameterListItem(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns3__subParameterListItem **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__subParameterListItem, sizeof(ns3__subParameterListItem), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__subParameterListItem(struct soap *soap, ns3__subParameterListItem *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons3__subParameterListItem(soap, tag ? tag : "ns3:subParameterListItem", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__subParameterListItem ** SOAP_FMAC4 soap_get_PointerTons3__subParameterListItem(struct soap *soap, ns3__subParameterListItem **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__subParameterListItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__responseParameterList(struct soap *soap, ns3__responseParameterList *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns3__responseParameterList))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__responseParameterList(struct soap *soap, const char *tag, int id, ns3__responseParameterList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns3__responseParameterList, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns3__responseParameterList ? type : NULL);
}

SOAP_FMAC3 ns3__responseParameterList ** SOAP_FMAC4 soap_in_PointerTons3__responseParameterList(struct soap *soap, const char *tag, ns3__responseParameterList **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__responseParameterList **)soap_malloc(soap, sizeof(ns3__responseParameterList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__responseParameterList *)soap_instantiate_ns3__responseParameterList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns3__responseParameterList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__responseParameterList, sizeof(ns3__responseParameterList), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__responseParameterList(struct soap *soap, ns3__responseParameterList *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons3__responseParameterList(soap, tag ? tag : "ns3:responseParameterList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__responseParameterList ** SOAP_FMAC4 soap_get_PointerTons3__responseParameterList(struct soap *soap, ns3__responseParameterList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__responseParameterList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__parameterListItem(struct soap *soap, ns2__parameterListItem *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__parameterListItem))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__parameterListItem(struct soap *soap, const char *tag, int id, ns2__parameterListItem *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__parameterListItem, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns2__parameterListItem ? type : NULL);
}

SOAP_FMAC3 ns2__parameterListItem ** SOAP_FMAC4 soap_in_PointerTons2__parameterListItem(struct soap *soap, const char *tag, ns2__parameterListItem **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__parameterListItem **)soap_malloc(soap, sizeof(ns2__parameterListItem *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__parameterListItem *)soap_instantiate_ns2__parameterListItem(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__parameterListItem **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__parameterListItem, sizeof(ns2__parameterListItem), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__parameterListItem(struct soap *soap, ns2__parameterListItem *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__parameterListItem(soap, tag ? tag : "ns2:parameterListItem", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__parameterListItem ** SOAP_FMAC4 soap_get_PointerTons2__parameterListItem(struct soap *soap, ns2__parameterListItem **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__parameterListItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__requestParameterList(struct soap *soap, ns2__requestParameterList *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__requestParameterList))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__requestParameterList(struct soap *soap, const char *tag, int id, ns2__requestParameterList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__requestParameterList, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns2__requestParameterList ? type : NULL);
}

SOAP_FMAC3 ns2__requestParameterList ** SOAP_FMAC4 soap_in_PointerTons2__requestParameterList(struct soap *soap, const char *tag, ns2__requestParameterList **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__requestParameterList **)soap_malloc(soap, sizeof(ns2__requestParameterList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__requestParameterList *)soap_instantiate_ns2__requestParameterList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__requestParameterList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__requestParameterList, sizeof(ns2__requestParameterList), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__requestParameterList(struct soap *soap, ns2__requestParameterList *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__requestParameterList(soap, tag ? tag : "ns2:requestParameterList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__requestParameterList ** SOAP_FMAC4 soap_get_PointerTons2__requestParameterList(struct soap *soap, ns2__requestParameterList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__requestParameterList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__string(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_std__string))
		soap_serialize_std__string(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__string(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_std__string, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_std__string(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTostd__string(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_std__string(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_std__string, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__string(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTostd__string(soap, tag ? tag : "string", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTostd__string(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE__QName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out__QName(soap, tag ? tag : "QName", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_string);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_new_string(struct soap *soap, int n)
{
	char * *a = static_cast<char * *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(char *)));
	for (char * *p = a; p && n--; ++p)
		soap_default_string(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_string(soap, tag ? tag : "string", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTo_ns22__alert(struct soap *soap, std::vector<_ns22__alert *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTo_ns22__alert(struct soap *soap, const std::vector<_ns22__alert *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<_ns22__alert *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTo_ns22__alert(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTo_ns22__alert(struct soap *soap, const char *tag, int id, const std::vector<_ns22__alert *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<_ns22__alert *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTo_ns22__alert(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<_ns22__alert *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTo_ns22__alert(struct soap *soap, const char *tag, std::vector<_ns22__alert *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTo_ns22__alert(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		_ns22__alert *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE__ns22__alert, SOAP_TYPE_std__vectorTemplateOfPointerTo_ns22__alert, sizeof(_ns22__alert), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTo_ns22__alert(soap, tag, NULL, ""))
				break;
		}
		else
		{	if (!soap_in_PointerTo_ns22__alert(soap, tag, &n, ""))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<_ns22__alert *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTo_ns22__alert(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTo_ns22__alert(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<_ns22__alert *> *p;
	size_t k = sizeof(std::vector<_ns22__alert *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTo_ns22__alert, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<_ns22__alert *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<_ns22__alert *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<_ns22__alert *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOf_XML(struct soap *soap, std::vector<char *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOf_XML(struct soap *soap, const std::vector<char *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOf_XML(struct soap *soap, const char *tag, int id, const std::vector<char *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<char *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_outliteral(soap, tag, (char*const*)&(*i), NULL))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<char *> * SOAP_FMAC4 soap_in_std__vectorTemplateOf_XML(struct soap *soap, const char *tag, std::vector<char *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOf_XML(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		char *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE__XML, SOAP_TYPE_std__vectorTemplateOf_XML, sizeof(char *), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_inliteral(soap, tag, NULL))
				break;
		}
		else
		{	if (!soap_inliteral(soap, tag, &n))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<char *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOf_XML(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOf_XML(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<char *> *p;
	size_t k = sizeof(std::vector<char *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOf_XML, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<char *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<char *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<char *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOf_ns22__alert_info(struct soap *soap, std::vector<_ns22__alert_info> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOf_ns22__alert_info(struct soap *soap, const std::vector<_ns22__alert_info> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<_ns22__alert_info> ::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOf_ns22__alert_info(struct soap *soap, const char *tag, int id, const std::vector<_ns22__alert_info> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<_ns22__alert_info> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<_ns22__alert_info> * SOAP_FMAC4 soap_in_std__vectorTemplateOf_ns22__alert_info(struct soap *soap, const char *tag, std::vector<_ns22__alert_info> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOf_ns22__alert_info(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		_ns22__alert_info n;
		n.soap_default(soap);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE__ns22__alert_info, SOAP_TYPE_std__vectorTemplateOf_ns22__alert_info, sizeof(_ns22__alert_info), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in__ns22__alert_info(soap, tag, NULL, ""))
				break;
		}
		else
		{	if (!soap_in__ns22__alert_info(soap, tag, &n, ""))
				break;
		}
		soap_end_shaky(soap, soap_shaky);
		if (a->size())
		{	const void *p = &*a->begin();
			soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(_ns22__alert_info));
			if (p != &*a->begin())
			{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container capacity increased: updating pointers\n"));
				soap_update_pointers(soap, (const char*)&*a->begin(), (const char*)p, (a->size() - 1) * sizeof(_ns22__alert_info));
			}
		}
		else
		{	soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(_ns22__alert_info));
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<_ns22__alert_info>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOf_ns22__alert_info(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOf_ns22__alert_info(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<_ns22__alert_info> *p;
	size_t k = sizeof(std::vector<_ns22__alert_info> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOf_ns22__alert_info, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<_ns22__alert_info> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<_ns22__alert_info> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<_ns22__alert_info>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOf_ns22__alert_info_area(struct soap *soap, std::vector<_ns22__alert_info_area> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOf_ns22__alert_info_area(struct soap *soap, const std::vector<_ns22__alert_info_area> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<_ns22__alert_info_area> ::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOf_ns22__alert_info_area(struct soap *soap, const char *tag, int id, const std::vector<_ns22__alert_info_area> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<_ns22__alert_info_area> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<_ns22__alert_info_area> * SOAP_FMAC4 soap_in_std__vectorTemplateOf_ns22__alert_info_area(struct soap *soap, const char *tag, std::vector<_ns22__alert_info_area> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOf_ns22__alert_info_area(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		_ns22__alert_info_area n;
		n.soap_default(soap);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE__ns22__alert_info_area, SOAP_TYPE_std__vectorTemplateOf_ns22__alert_info_area, sizeof(_ns22__alert_info_area), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in__ns22__alert_info_area(soap, tag, NULL, ""))
				break;
		}
		else
		{	if (!soap_in__ns22__alert_info_area(soap, tag, &n, ""))
				break;
		}
		soap_end_shaky(soap, soap_shaky);
		if (a->size())
		{	const void *p = &*a->begin();
			soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(_ns22__alert_info_area));
			if (p != &*a->begin())
			{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container capacity increased: updating pointers\n"));
				soap_update_pointers(soap, (const char*)&*a->begin(), (const char*)p, (a->size() - 1) * sizeof(_ns22__alert_info_area));
			}
		}
		else
		{	soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(_ns22__alert_info_area));
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<_ns22__alert_info_area>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOf_ns22__alert_info_area(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOf_ns22__alert_info_area(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<_ns22__alert_info_area> *p;
	size_t k = sizeof(std::vector<_ns22__alert_info_area> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOf_ns22__alert_info_area, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<_ns22__alert_info_area> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<_ns22__alert_info_area> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<_ns22__alert_info_area>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOf_ns22__alert_info_area_geocode(struct soap *soap, std::vector<_ns22__alert_info_area_geocode> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOf_ns22__alert_info_area_geocode(struct soap *soap, const std::vector<_ns22__alert_info_area_geocode> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<_ns22__alert_info_area_geocode> ::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOf_ns22__alert_info_area_geocode(struct soap *soap, const char *tag, int id, const std::vector<_ns22__alert_info_area_geocode> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<_ns22__alert_info_area_geocode> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<_ns22__alert_info_area_geocode> * SOAP_FMAC4 soap_in_std__vectorTemplateOf_ns22__alert_info_area_geocode(struct soap *soap, const char *tag, std::vector<_ns22__alert_info_area_geocode> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOf_ns22__alert_info_area_geocode(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		_ns22__alert_info_area_geocode n;
		n.soap_default(soap);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE__ns22__alert_info_area_geocode, SOAP_TYPE_std__vectorTemplateOf_ns22__alert_info_area_geocode, sizeof(_ns22__alert_info_area_geocode), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in__ns22__alert_info_area_geocode(soap, tag, NULL, ""))
				break;
		}
		else
		{	if (!soap_in__ns22__alert_info_area_geocode(soap, tag, &n, ""))
				break;
		}
		soap_end_shaky(soap, soap_shaky);
		if (a->size())
		{	const void *p = &*a->begin();
			soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(_ns22__alert_info_area_geocode));
			if (p != &*a->begin())
			{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container capacity increased: updating pointers\n"));
				soap_update_pointers(soap, (const char*)&*a->begin(), (const char*)p, (a->size() - 1) * sizeof(_ns22__alert_info_area_geocode));
			}
		}
		else
		{	soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(_ns22__alert_info_area_geocode));
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<_ns22__alert_info_area_geocode>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOf_ns22__alert_info_area_geocode(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOf_ns22__alert_info_area_geocode(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<_ns22__alert_info_area_geocode> *p;
	size_t k = sizeof(std::vector<_ns22__alert_info_area_geocode> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOf_ns22__alert_info_area_geocode, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<_ns22__alert_info_area_geocode> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<_ns22__alert_info_area_geocode> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<_ns22__alert_info_area_geocode>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOf_ns22__alert_info_resource(struct soap *soap, std::vector<_ns22__alert_info_resource> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOf_ns22__alert_info_resource(struct soap *soap, const std::vector<_ns22__alert_info_resource> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<_ns22__alert_info_resource> ::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOf_ns22__alert_info_resource(struct soap *soap, const char *tag, int id, const std::vector<_ns22__alert_info_resource> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<_ns22__alert_info_resource> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<_ns22__alert_info_resource> * SOAP_FMAC4 soap_in_std__vectorTemplateOf_ns22__alert_info_resource(struct soap *soap, const char *tag, std::vector<_ns22__alert_info_resource> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOf_ns22__alert_info_resource(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		_ns22__alert_info_resource n;
		n.soap_default(soap);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE__ns22__alert_info_resource, SOAP_TYPE_std__vectorTemplateOf_ns22__alert_info_resource, sizeof(_ns22__alert_info_resource), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in__ns22__alert_info_resource(soap, tag, NULL, ""))
				break;
		}
		else
		{	if (!soap_in__ns22__alert_info_resource(soap, tag, &n, ""))
				break;
		}
		soap_end_shaky(soap, soap_shaky);
		if (a->size())
		{	const void *p = &*a->begin();
			soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(_ns22__alert_info_resource));
			if (p != &*a->begin())
			{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container capacity increased: updating pointers\n"));
				soap_update_pointers(soap, (const char*)&*a->begin(), (const char*)p, (a->size() - 1) * sizeof(_ns22__alert_info_resource));
			}
		}
		else
		{	soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(_ns22__alert_info_resource));
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<_ns22__alert_info_resource>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOf_ns22__alert_info_resource(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOf_ns22__alert_info_resource(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<_ns22__alert_info_resource> *p;
	size_t k = sizeof(std::vector<_ns22__alert_info_resource> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOf_ns22__alert_info_resource, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<_ns22__alert_info_resource> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<_ns22__alert_info_resource> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<_ns22__alert_info_resource>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOf_ns22__alert_info_parameter(struct soap *soap, std::vector<_ns22__alert_info_parameter> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOf_ns22__alert_info_parameter(struct soap *soap, const std::vector<_ns22__alert_info_parameter> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<_ns22__alert_info_parameter> ::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOf_ns22__alert_info_parameter(struct soap *soap, const char *tag, int id, const std::vector<_ns22__alert_info_parameter> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<_ns22__alert_info_parameter> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<_ns22__alert_info_parameter> * SOAP_FMAC4 soap_in_std__vectorTemplateOf_ns22__alert_info_parameter(struct soap *soap, const char *tag, std::vector<_ns22__alert_info_parameter> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOf_ns22__alert_info_parameter(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		_ns22__alert_info_parameter n;
		n.soap_default(soap);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE__ns22__alert_info_parameter, SOAP_TYPE_std__vectorTemplateOf_ns22__alert_info_parameter, sizeof(_ns22__alert_info_parameter), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in__ns22__alert_info_parameter(soap, tag, NULL, ""))
				break;
		}
		else
		{	if (!soap_in__ns22__alert_info_parameter(soap, tag, &n, ""))
				break;
		}
		soap_end_shaky(soap, soap_shaky);
		if (a->size())
		{	const void *p = &*a->begin();
			soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(_ns22__alert_info_parameter));
			if (p != &*a->begin())
			{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container capacity increased: updating pointers\n"));
				soap_update_pointers(soap, (const char*)&*a->begin(), (const char*)p, (a->size() - 1) * sizeof(_ns22__alert_info_parameter));
			}
		}
		else
		{	soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(_ns22__alert_info_parameter));
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<_ns22__alert_info_parameter>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOf_ns22__alert_info_parameter(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOf_ns22__alert_info_parameter(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<_ns22__alert_info_parameter> *p;
	size_t k = sizeof(std::vector<_ns22__alert_info_parameter> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOf_ns22__alert_info_parameter, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<_ns22__alert_info_parameter> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<_ns22__alert_info_parameter> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<_ns22__alert_info_parameter>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOf_ns22__alert_info_eventCode(struct soap *soap, std::vector<_ns22__alert_info_eventCode> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOf_ns22__alert_info_eventCode(struct soap *soap, const std::vector<_ns22__alert_info_eventCode> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<_ns22__alert_info_eventCode> ::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOf_ns22__alert_info_eventCode(struct soap *soap, const char *tag, int id, const std::vector<_ns22__alert_info_eventCode> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<_ns22__alert_info_eventCode> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<_ns22__alert_info_eventCode> * SOAP_FMAC4 soap_in_std__vectorTemplateOf_ns22__alert_info_eventCode(struct soap *soap, const char *tag, std::vector<_ns22__alert_info_eventCode> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOf_ns22__alert_info_eventCode(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		_ns22__alert_info_eventCode n;
		n.soap_default(soap);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE__ns22__alert_info_eventCode, SOAP_TYPE_std__vectorTemplateOf_ns22__alert_info_eventCode, sizeof(_ns22__alert_info_eventCode), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in__ns22__alert_info_eventCode(soap, tag, NULL, ""))
				break;
		}
		else
		{	if (!soap_in__ns22__alert_info_eventCode(soap, tag, &n, ""))
				break;
		}
		soap_end_shaky(soap, soap_shaky);
		if (a->size())
		{	const void *p = &*a->begin();
			soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(_ns22__alert_info_eventCode));
			if (p != &*a->begin())
			{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container capacity increased: updating pointers\n"));
				soap_update_pointers(soap, (const char*)&*a->begin(), (const char*)p, (a->size() - 1) * sizeof(_ns22__alert_info_eventCode));
			}
		}
		else
		{	soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(_ns22__alert_info_eventCode));
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<_ns22__alert_info_eventCode>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOf_ns22__alert_info_eventCode(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOf_ns22__alert_info_eventCode(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<_ns22__alert_info_eventCode> *p;
	size_t k = sizeof(std::vector<_ns22__alert_info_eventCode> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOf_ns22__alert_info_eventCode, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<_ns22__alert_info_eventCode> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<_ns22__alert_info_eventCode> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<_ns22__alert_info_eventCode>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOf_ns22__alert_info_responseType(struct soap *soap, std::vector<enum _ns22__alert_info_responseType> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOf_ns22__alert_info_responseType(struct soap *soap, const std::vector<enum _ns22__alert_info_responseType> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOf_ns22__alert_info_responseType(struct soap *soap, const char *tag, int id, const std::vector<enum _ns22__alert_info_responseType> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<enum _ns22__alert_info_responseType> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out__ns22__alert_info_responseType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<enum _ns22__alert_info_responseType> * SOAP_FMAC4 soap_in_std__vectorTemplateOf_ns22__alert_info_responseType(struct soap *soap, const char *tag, std::vector<enum _ns22__alert_info_responseType> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOf_ns22__alert_info_responseType(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		enum _ns22__alert_info_responseType n;
		soap_default__ns22__alert_info_responseType(soap, &n);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE__ns22__alert_info_responseType, SOAP_TYPE_std__vectorTemplateOf_ns22__alert_info_responseType, sizeof(enum _ns22__alert_info_responseType), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in__ns22__alert_info_responseType(soap, tag, NULL, "ns22:alert-info-responseType"))
				break;
		}
		else
		{	if (!soap_in__ns22__alert_info_responseType(soap, tag, &n, "ns22:alert-info-responseType"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<enum _ns22__alert_info_responseType>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOf_ns22__alert_info_responseType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOf_ns22__alert_info_responseType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<enum _ns22__alert_info_responseType> *p;
	size_t k = sizeof(std::vector<enum _ns22__alert_info_responseType> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOf_ns22__alert_info_responseType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<enum _ns22__alert_info_responseType> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<enum _ns22__alert_info_responseType> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<enum _ns22__alert_info_responseType>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOf_ns22__alert_info_category(struct soap *soap, std::vector<enum _ns22__alert_info_category> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOf_ns22__alert_info_category(struct soap *soap, const std::vector<enum _ns22__alert_info_category> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOf_ns22__alert_info_category(struct soap *soap, const char *tag, int id, const std::vector<enum _ns22__alert_info_category> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<enum _ns22__alert_info_category> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out__ns22__alert_info_category(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<enum _ns22__alert_info_category> * SOAP_FMAC4 soap_in_std__vectorTemplateOf_ns22__alert_info_category(struct soap *soap, const char *tag, std::vector<enum _ns22__alert_info_category> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOf_ns22__alert_info_category(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		enum _ns22__alert_info_category n;
		soap_default__ns22__alert_info_category(soap, &n);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE__ns22__alert_info_category, SOAP_TYPE_std__vectorTemplateOf_ns22__alert_info_category, sizeof(enum _ns22__alert_info_category), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in__ns22__alert_info_category(soap, tag, NULL, "ns22:alert-info-category"))
				break;
		}
		else
		{	if (!soap_in__ns22__alert_info_category(soap, tag, &n, "ns22:alert-info-category"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<enum _ns22__alert_info_category>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOf_ns22__alert_info_category(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOf_ns22__alert_info_category(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<enum _ns22__alert_info_category> *p;
	size_t k = sizeof(std::vector<enum _ns22__alert_info_category> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOf_ns22__alert_info_category, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<enum _ns22__alert_info_category> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<enum _ns22__alert_info_category> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<enum _ns22__alert_info_category>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons3__subParameterListItem(struct soap *soap, std::vector<ns3__subParameterListItem *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons3__subParameterListItem(struct soap *soap, const std::vector<ns3__subParameterListItem *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns3__subParameterListItem *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons3__subParameterListItem(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons3__subParameterListItem(struct soap *soap, const char *tag, int id, const std::vector<ns3__subParameterListItem *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns3__subParameterListItem *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons3__subParameterListItem(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns3__subParameterListItem *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons3__subParameterListItem(struct soap *soap, const char *tag, std::vector<ns3__subParameterListItem *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons3__subParameterListItem(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns3__subParameterListItem *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_ns3__subParameterListItem, SOAP_TYPE_std__vectorTemplateOfPointerTons3__subParameterListItem, sizeof(ns3__subParameterListItem), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTons3__subParameterListItem(soap, tag, NULL, "ns3:subParameterListItem"))
				break;
		}
		else
		{	if (!soap_in_PointerTons3__subParameterListItem(soap, tag, &n, "ns3:subParameterListItem"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns3__subParameterListItem *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons3__subParameterListItem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons3__subParameterListItem(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns3__subParameterListItem *> *p;
	size_t k = sizeof(std::vector<ns3__subParameterListItem *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTons3__subParameterListItem, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<ns3__subParameterListItem *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<ns3__subParameterListItem *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns3__subParameterListItem *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTo_ns3__parameterListItem(struct soap *soap, std::vector<_ns3__parameterListItem *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTo_ns3__parameterListItem(struct soap *soap, const std::vector<_ns3__parameterListItem *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<_ns3__parameterListItem *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTo_ns3__parameterListItem(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTo_ns3__parameterListItem(struct soap *soap, const char *tag, int id, const std::vector<_ns3__parameterListItem *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<_ns3__parameterListItem *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTo_ns3__parameterListItem(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<_ns3__parameterListItem *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTo_ns3__parameterListItem(struct soap *soap, const char *tag, std::vector<_ns3__parameterListItem *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTo_ns3__parameterListItem(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		_ns3__parameterListItem *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE__ns3__parameterListItem, SOAP_TYPE_std__vectorTemplateOfPointerTo_ns3__parameterListItem, sizeof(_ns3__parameterListItem), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTo_ns3__parameterListItem(soap, tag, NULL, ""))
				break;
		}
		else
		{	if (!soap_in_PointerTo_ns3__parameterListItem(soap, tag, &n, ""))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<_ns3__parameterListItem *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTo_ns3__parameterListItem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTo_ns3__parameterListItem(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<_ns3__parameterListItem *> *p;
	size_t k = sizeof(std::vector<_ns3__parameterListItem *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTo_ns3__parameterListItem, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<_ns3__parameterListItem *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<_ns3__parameterListItem *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<_ns3__parameterListItem *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfstd__string(struct soap *soap, std::vector<std::string> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfstd__string(struct soap *soap, const std::vector<std::string> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<std::string> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_std__string(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfstd__string(struct soap *soap, const char *tag, int id, const std::vector<std::string> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<std::string> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_std__string(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<std::string> * SOAP_FMAC4 soap_in_std__vectorTemplateOfstd__string(struct soap *soap, const char *tag, std::vector<std::string> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfstd__string(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		std::string n;
		soap_default_std__string(soap, &n);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_std__string, SOAP_TYPE_std__vectorTemplateOfstd__string, sizeof(std::string), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in_std__string(soap, tag, NULL, "xsd:string"))
				break;
		}
		else
		{	if (!soap_in_std__string(soap, tag, &n, "xsd:string"))
				break;
		}
		soap_end_shaky(soap, soap_shaky);
		if (a->size())
		{	const void *p = &*a->begin();
			soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(std::string));
			if (p != &*a->begin())
			{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container capacity increased: updating pointers\n"));
				soap_update_pointers(soap, (const char*)&*a->begin(), (const char*)p, (a->size() - 1) * sizeof(std::string));
			}
		}
		else
		{	soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(std::string));
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<std::string>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfstd__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfstd__string(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<std::string> *p;
	size_t k = sizeof(std::vector<std::string> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfstd__string, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<std::string> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<std::string> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<std::string>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons2__parameterListItem(struct soap *soap, std::vector<ns2__parameterListItem *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons2__parameterListItem(struct soap *soap, const std::vector<ns2__parameterListItem *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns2__parameterListItem *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons2__parameterListItem(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons2__parameterListItem(struct soap *soap, const char *tag, int id, const std::vector<ns2__parameterListItem *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns2__parameterListItem *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons2__parameterListItem(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns2__parameterListItem *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons2__parameterListItem(struct soap *soap, const char *tag, std::vector<ns2__parameterListItem *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons2__parameterListItem(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns2__parameterListItem *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_ns2__parameterListItem, SOAP_TYPE_std__vectorTemplateOfPointerTons2__parameterListItem, sizeof(ns2__parameterListItem), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTons2__parameterListItem(soap, tag, NULL, "ns2:parameterListItem"))
				break;
		}
		else
		{	if (!soap_in_PointerTons2__parameterListItem(soap, tag, &n, "ns2:parameterListItem"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns2__parameterListItem *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons2__parameterListItem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons2__parameterListItem(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns2__parameterListItem *> *p;
	size_t k = sizeof(std::vector<ns2__parameterListItem *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTons2__parameterListItem, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<ns2__parameterListItem *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<ns2__parameterListItem *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns2__parameterListItem *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC.cpp */
